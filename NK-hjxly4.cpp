//链接：https://ac.nowcoder.com/acm/contest/
//来源：牛客网
/* A  √
本场比赛灵感来源于树状数组出题组

题目描述
怎么出一场区域赛题目？简单，放 2 道签到题和 8 道构造题就行了。
老八提出了八氏二分法，在数组中，对于第
𝑥
x 个数字
𝑎
𝑥
a
x
​
 ，如果其他数字中有至少
80
%
80% 的数字小于等于
𝑎
𝑥
a
x
​
 ，则将第
𝑥
x 个数字分在 A 组，否则分在 B 组。
求 A 组中的数字之和。
输入描述:
第一行输入一个正整数
𝑛
(
2
≤
𝑛
≤
1
0
3
)
n(2≤n≤10
3
 )，表示数组大小。
第二行输入
𝑛
n 个整数
𝑎
1
,
𝑎
2
,
…
,
𝑎
𝑛
(
1
≤
𝑎
𝑖
≤
1
0
3
)
a
1
​
 ,a
2
​
 ,…,a
n
​
 (1≤a
i
​
 ≤10
3
 )，表示数组。
输出描述:
输出一个整数表示答案。
示例1
输入
复制
6
1 1 4 5 1 4
输出
复制
13
说明
对于这组数据：
∙
 
∙对于第一个数字，在除了它以外的
5
5 个数字中，只有
2
2 个数字小于等于它，不到
80
%
80%，因此分在 B 组；
∙
 
∙对于第二个数字，只有
2
2 个数字小于等于它，不到
80
%
80%，因此分在 B 组；
∙
 
∙对于第三个数字，只有
4
4 个数字小于等于它，达到
80
%
80%，因此分在 A 组；
∙
 
∙对于第四个数字，只有
5
5 个数字小于等于它，达到
80
%
80%，因此分在 A 组；
∙
 
∙对于第五个数字，只有
2
2 个数字小于等于它，不到
80
%
80%，因此分在 B 组；
∙
 
∙对于第六个数字，只有
4
4 个数字小于等于它，达到
80
%
80%，因此分在 A 组。
综上，A 组中的数字之和为
4
+
5
+
4
=
13
4+5+4=13。
*
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main()
{
    int n, m, h;
    long long num = 0;
    cin >> n;
    vector<int>a(n + 1);
    m = n * 0.8 + 1;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a.begin(), a.end());
    h = a[m];
    for (int i = n; a[i] >= h; i--)
        num += a[i];
    cout << num << endl;

    return 0;
}
*/

/* B √
构造部落

题目描述
由于残暴的文字狱，后续题目名字“构造王国”等被迫改名。
部落时代对于我们已经非常遥远了，因此部落时代的时间我们很难精确的描述。
我们已知部落时代有
n
n 位首领，第
1
1 位部落首领在位的第
1
1 年为公元
s
s 年，还知道第
i
i 位首领在位时间
t
i
t
i
​
 ，在此我们假设每一位首领的在位时间都恰好为整数年。
n
n 位首领按编号顺序连续在位，即第
i
i 位首领在位结束后的次年，第
i
+
1
i+1 位首领立即即位。
现在，考古学家发现了
q
q 件文物，每件文物上记录了在第
x
x 位首领在位的第
y
y 年发生的事件，你需要帮助考古学家确定每个事件发生在公元多少年。
输入描述:
第一行输入三个整数
n
,
q
,
s
(
1
≤
n
,
q
≤
2
×
1
0
5
;
 
−
1
0
9
≤
s
≤
1
0
9
)
n,q,s(1≤n,q≤2×10
5
 ;−10
9
 ≤s≤10
9
 )，表示部落首领数量，文物数量，第一位部落首领在位的第一年的公元年份。
第二行输入
n
n 个正整数
t
1
,
t
2
,
…
,
t
n
(
1
≤
t
i
≤
5
×
1
0
3
)
t
1
​
 ,t
2
​
 ,…,t
n
​
 (1≤t
i
​
 ≤5×10
3
 )，表示每一位首领在位的年数。
此后
q
q 行，第
i
i 行输入两个整数
x
i
,
y
i
(
1
≤
x
i
≤
n
;
 
1
≤
y
i
≤
t
x
i
)
x
i
​
 ,y
i
​
 (1≤x
i
​
 ≤n;1≤y
i
​
 ≤t
x
i
​

​
 ) 表示第
i
i 件文物记录的是第
x
i
x
i
​
  位首领在位的第
y
i
y
i
​
  年。
输出描述:
对于每一件文物，新起一行输出一个整数，表示该事件发生在公元多少年。
示例1
输入
复制
6 3 0
1 1 4 5 1 4
1 1
3 3
4 4
输出
复制
0
4
9
说明
在这个样例中：
∙
 
∙第一位首领在位的第
1
1 年为公元
0
0 年；
∙
 
∙第二位首领在位的第
1
1 年为公元
1
1 年；
∙
 
∙第三位首领在位的第
1
1 年为公元
2
2 年，在位的第
3
3 年为公元
4
4 年；
∙
 
∙第四位首领在位的第
1
1 年为公元
6
6 年，在位的第
4
4 年为公元
9
9 年。
示例2
输入
复制
6 4 8
1 1 4 5 1 4
1 1
3 3
4 4
4 5
输出
复制
8
12
17
18
*
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main()
{
    int n, m, h, x, y;
    cin >> n >> m;
    vector<int>a(n + 2);
    cin >> a[1];
    for (int i = 2; i < n + 2; i++)
    {
        cin >> h;
        a[i] = a[i - 1] + h;
    }
    for (int i = 0; i < m; i++)
    {
        cin >> x >> y;
        cout << a[x] + y - 1 << endl;
    }

    return 0;
}
*/

/* C √
墨提斯的排列

题目描述
排列相邻位异或起来求和——和异位！
萨莉亚——和意味！
墨提斯想构造一个长度为
2
n
2
n
  的排列
p
0
,
p
1
,
…
,
p
(
2
n
−
1
)
p
0
​
 ,p
1
​
 ,…,p
(2
n
 −1)
​
 ，使得相邻两项异或值之和最小。换句话说，最小化：

∑
i
=
1
2
n
−
1
(
p
i
−
1
⊕
p
i
)
i=1
∑
2
n
 −1
​
 (p
i−1
​
 ⊕p
i
​
 )

可以证明，最优解一定存在。

【名词解释】
长度为
n
n 的排列：由
0
,
1
,
…
,
n
−
1
0,1,…,n−1 这
n
n 个整数、按任意顺序组成的数组（每个整数均恰好出现一次）。例如，
{
1
,
2
,
0
,
4
,
3
}
{1,2,0,4,3} 是一个长度为
5
5 的排列，而
{
0
,
1
,
1
}
{0,1,1} 和
{
0
,
2
,
3
}
{0,2,3} 都不是排列，因为前者存在重复元素，后者包含了超出范围的数。
⊕
⊕：指位运算中的按位异或（Bitwise XOR），对两个整数的二进制表示按位进行异或运算。如果您需要更多位运算相关的知识，可以参考 OI-Wiki的相关章节。
输入描述:
输入一个正整数
n
(
1
≤
n
≤
18
)
n(1≤n≤18)。
输出描述:
在一行中输出
2
n
2
n
  个整数，表示构造的排列。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
1
输出
复制
0 1
说明
在这个样例中，输出
{
0
,
1
}
{0,1} 和
{
1
,
0
}
{1,0} 都是合法的答案。
*
#include<iostream>
using namespace std;
int main()
{
    int n, count;
    cin >> n;
    count = 1 << n;
    for (int i = 0; i < count; i++)
        cout << (i ^ (i >> 1)) << ' ';

    return 0;
}
*/

/* D
东风谷早苗与博丽灵梦

题目描述
这个国家的人一般都体型偏瘦而且人口老龄化严重，为什么呢？
有一个长度为
x
x 的线段，早苗站在线段左端点，灵梦站在线段右端点。早苗每秒可以向右移动
a
a 个单位长度，灵梦每秒可以向左移动
s
s 个单位长度。早苗和灵梦每秒可以分别选择移动、不移动，一旦选择移动，必须完整走完这一秒而不能中途停，并且移动过程中不能超出线段端点。
请构造一个方案，使得在某一秒结束时，两人恰好处于同一坐标（即相遇），且用时最短。方案仅需给出两个非负整数
c
1
,
c
2
c
1
​
 ,c
2
​
 ，分别表示早苗的移动次数和灵梦的移动次数，且最小化
max
⁡
(
c
1
,
c
2
)
max(c
1
​
 ,c
2
​
 )。如果不存在符合条件的方案，直接输出
No
No。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≤
T
≤
1
0
4
)
T(1≤T≤10
4
 ) 代表数据组数，每组测试数据描述如下：

在一行上输入三个正整数
x
,
a
,
s
(
1
≤
x
,
a
,
s
≤
1
0
18
)
x,a,s(1≤x,a,s≤10
18
 ) ，表示线段长度，早苗移动速度，灵梦移动速度。
输出描述:
对于每一组测试数据，新起一行。如果不存在符合条件的方案，直接输出
No
No，否则：
∙
 
∙第一行输出
Yes
Yes；
∙
 
∙第二行输出两个非负整数
c
1
,
c
2
c
1
​
 ,c
2
​
 ，分别表示早苗、灵梦的移动次数；

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2
2 1 1
1 2 2
输出
复制
Yes
1 1
No
说明

*
#include<iostream>
using namespace std;
int main()
{
    long long t, s, x, y, u, v, l, i;
    bool k;
    cin >> t;
    while (t--)
    {
        u = v = -1;
        cin >> s >> x >> y;
        k = x < y;
        if (k)x += y, y = x - y, x -= y;
        if (y)
            for (i = s / x; i >= 0; i--)
            {
                l = s - x * i;
                if (!(l % y))
                {
                    u = i, v = l / y;
                    break;
                }
            }
        else if (x && !(s % x))
            u = s / x, v = 0;
        if (u != -1)
        {
            cout << "Yes" << endl;
            if (x == y)cout << (long long)(u / 2.0 + 0.5) << ' ' << u / 2 << endl;
            else if (k)cout << v << ' ' << u << endl;
            else cout << u << ' ' << v << endl;
        }
        else cout << "No" << endl;
    }

    return 0;
}
*/

/* E
立希的扫雷构造

题目描述
你知道吗，鱿鱼不仅能做鱿鱼丝，还能做肥皂呢。
扫雷是一款经典游戏，游戏中有一张网格图，每一个格子要么是“地雷”、要么是“空地”。定义一个“空地”的危险值为周围
8
8 个格子中“地雷”的个数；“地雷”格子的危险值为
0
0。
立希为了狩猎鱿鱼，现在她需要在一个大小为
n
×
m
n×m 的网格图中布置
k
k 个地雷，使得所有格子的危险值之和最大。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≤
T
≤
1
0
4
)
T(1≤T≤10
4
 ) 代表数据组数，每组测试数据描述如下：

在一行上输入三个整数
n
,
m
,
k
(
1
≤
n
,
m
≤
9
;
 
0
≤
k
≤
n
×
m
)
n,m,k(1≤n,m≤9;0≤k≤n×m)，表示网格图的长宽、地雷数量。
输出描述:
对于每一组测试数据，第一行输出一个整数，表示所有网格的危险值之和；此后
n
n 行，每行输出一个长度为
m
m，仅由字符
.
. 和
*
* 组成的字符串
s
i
,
1
s
i
,
2
⋯
s
i
,
m
s
i,1
​
 s
i,2
​
 ⋯s
i,m
​
 ，表示你所构造的网格图。其中，第
j
j 个字符
s
i
,
j
=
*
s
i,j
​
 =* 表示第
i
i 行第
j
j 列的格子为“地雷”；否则表示为“空地”。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2
3 3 1
3 3 3
输出
复制
8
...
.*.
...
14
...
***
...
说明
对于第一组测试数据，每一个网格的危险值为：
[
1
1
1
1
0
1
1
1
1
]
⎣
⎡
​

1
1
1
​

1
0
1
​

1
1
1
​

⎦
⎤
​
 ，总危险值为
8
8。

对于第二组测试数据，每一个网格的危险值为：
[
2
3
2
0
0
0
2
3
2
]
⎣
⎡
​

2
0
2
​

3
0
3
​

2
0
2
​

⎦
⎤
​
 ，总危险值为
14
14。
*/

/* F √
爱音的01串构造

题目描述
“这里是天堂吗？”——0.5如是说。
爱音想要构造一个由
a
a 个
0
0 和
b
b 个
1
1 组成的 01 字符串，且使得这个 01 字符串所有非空连续子串的
mex
⁡
mex 之和最大。

在本题中，01 串的
mex
⁡
mex 定义为：字符串最小未出现的非负整数。例如，
mex
⁡
(
"0"
)
=
1
mex("0")=1、
mex
⁡
(
"1"
)
=
0
mex("1")=0、
mex
⁡
(
"1100"
)
=
2
mex("1100")=2。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≤
T
≤
1
0
5
)
T(1≤T≤10
5
 ) 代表数据组数，每组测试数据描述如下：

在一行上输入两个整数
a
,
b
(
0
≤
a
,
b
≤
1
0
5
;
 
0
<
a
+
b
)
a,b(0≤a,b≤10
5
 ;0<a+b)，表示字符串中
0
0 的个数、
1
1 的个数。

除此之外，保证单个测试文件的
a
a 之和、
b
b 之和均不超过
2
×
1
0
5
2×10
5
 。
输出描述:
对于每一组测试数据，新起一行输出一个 01 串，表示你所构造的字符串。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2
1 1
2 1
输出
复制
01
010
说明
对于第一组测试数据，字符串
"01"
"01" 和
"10"
"10" 都是合法的答案。具体地，对于字符串
"01"
"01"，其所有非空连续子串为：
∙
 
∙
"0"
"0"，
mex
⁡
=
1
mex=1；
∙
 
∙
"1"
"1"，
mex
⁡
=
0
mex=0；
∙
 
∙
"01"
"01"，
mex
⁡
=
2
mex=2。
总和为
1
+
0
+
2
=
3
1+0+2=3。
示例2
输入
复制
1
2 1
输出
复制
010
*
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int t, n, m, x, y;
    char a, b;
    string s;
    cin >> t;
    while (t--)
    {
        s = "";
        cin >> n >> m;
        if (n >= m)a = '0', b = '1';
        else n += m, m = n - m, n -= m, a = '1', b = '0';
        x = n / (m + 1), y = m - n % (m + 1);
        for (int i = 0; i < x; i++)
            s += a;
        for (int i = 0; i <= m; i++)
        {
            if (i)cout << b;
            cout << s;
            if (i == y)s += a;
        }
        cout << endl;
    }

    return 0;
}
*/

/* G
真白的幻觉

题目描述
这道题很简单，只需要两只手各举起一个数字就可以了。
mashiro 吃菌子中毒时发现将数字按位累乘非常好玩，于是她决定好好研究一下。

定义
f
(
x
)
f(x) 为将
x
x 的每一位数字相乘的结果，例如
f
(
21
)
=
2
×
1
=
2
f(21)=2×1=2、
f
(
42
)
=
4
×
2
=
8
f(42)=4×2=8、
f
(
84
)
=
8
×
4
=
32
f(84)=8×4=32、
f
(
114514
)
=
80
f(114514)=80 等等。
定义
g
(
x
)
g(x) 为
x
:
=
f
(
x
)
(
x
≠
f
(
x
)
)
x:=f(x)(x

​
 =f(x)) 可以执行的次数，即重复执行操作“当
x
≠
f
(
x
)
x

​
 =f(x) 时令
x
:
=
f
(
x
)
x:=f(x)”，直到出现
x
=
f
(
x
)
x=f(x) 为止需要的执行次数。

构造两个不超过
1
0
18
10
18
  的正整数
a
,
b
a,b，最大化
g
(
a
)
+
g
(
b
)
g(a)+g(b) 的值，且
f
(
a
)
≠
f
(
b
)
f(a)

​
 =f(b)。
输入描述:
本题不需要处理输入。
输出描述:
在一行上输出两个正整数，表示答案。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
（无输入）
输出
复制
1 23
说明
样例仅供输出参考。
我没要求你永远都出很好的题，我不是恶魔。
可是，输出两个整数什么意思？你的出题观念怎么了？你才21岁吧？再这样下去，你42岁输出四个数，84岁输出八个数，最后就变成八常大数了。
作为正义做题人，我可能得打败你。真的。
备注:

*/

/* H √
时不时使使用玉米加农炮掩饰害羞的邻座艾莉同学

题目描述
“这个构造题太垃圾了！！！！！”
“你泄露题目机密，unrate，扣200分，标记为作弊！”
“我都没说的是我骂的是哪个构造题，你怎么能扣我分？”
“别撒谎了，我出过二十年的构造题了，难道我不知道哪个构造题是垃圾吗？”
艾莉同学开发了一种名为“玉米加农炮”的武器，使用“玉米加农炮”需要选择一个坐标为
(
x
,
y
)
(x,y) 的方格，“玉米加农炮”会消灭与方格
(
x
,
y
)
(x,y) 曼哈顿距离不超过
2
2 的方格上的所有敌人。

现在，在一张
n
n 行
m
m 列的地图上，我们使用
(
i
,
j
)
(i,j) 表示网格中从上往下数第
i
i 行和从左往右数第
j
j 列的单元格，单元格内有
a
i
,
j
a
i,j
​
  名敌人。敌方会进行
q
q 次增援，每次增援会在坐标为
(
x
,
y
)
(x,y) 的方格中增加
z
z 名敌人。
你需要在敌方每次进行增援后，找到一个使用“玉米加农炮”后可以消灭最多敌人的方格（仅寻找位置，不会真的消灭）。即：输出两个整数表示所选方格的坐标，使得对所选方格使用“玉米加农炮”可以消灭的敌人数量为所有方格中的最大值，若有多个方格可以消灭的敌人数量相同且最大，输出任意一个即可。

【名词解释】
曼哈顿距离：对于网格图中的两个点
(
x
1
,
y
1
)
(x
1
​
 ,y
1
​
 ) 和
(
x
2
,
y
2
)
(x
2
​
 ,y
2
​
 )，其曼哈顿距离为
∣
x
1
−
x
2
∣
+
∣
y
1
−
y
2
∣
∣x
1
​
 −x
2
​
 ∣+∣y
1
​
 −y
2
​
 ∣。
输入描述:
第一行输入三个正整数
n
,
m
,
q
(
1
≤
n
,
m
≤
500
;
 
1
≤
q
≤
1
0
5
)
n,m,q(1≤n,m≤500;1≤q≤10
5
 )，表示地图的行数、列数、增援次数。
此后
n
n 行，第
i
i 行输入
m
m 个整数
a
i
,
1
,
a
i
,
2
,
…
,
a
i
,
m
(
0
≤
a
i
,
j
≤
1
0
8
)
a
i,1
​
 ,a
i,2
​
 ,…,a
i,m
​
 (0≤a
i,j
​
 ≤10
8
 )，表示地图。
此后
q
q 行，第
i
i 行输入三个正整数
x
i
,
y
i
,
z
i
(
1
≤
x
i
≤
n
;
 
1
≤
y
i
≤
m
;
 
1
≤
z
i
≤
1
0
8
)
x
i
​
 ,y
i
​
 ,z
i
​
 (1≤x
i
​
 ≤n;1≤y
i
​
 ≤m;1≤z
i
​
 ≤10
8
 )，表示第
i
i 次增援。
输出描述:
对于每一次增援，新起一行输出两个整数，表示所选方格的坐标。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
3 3 2
1 1 0
1 0 0
0 0 0
2 2 2
3 3 3
输出
复制
1 1
2 2
说明
在这个样例中，第
1
1 次增援后，地图变成：
[
1
1
0
1
2
0
0
0
0
]
⎣
⎡
​

1
1
0
​

1
2
0
​

0
0
0
​

⎦
⎤
​
 。此时，对
(
1
,
1
)
(1,1)、
(
1
,
2
)
(1,2)、
(
2
,
1
)
(2,1)、
(
2
,
2
)
(2,2) 中任意一个方格使用“玉米加农炮”均可以消灭
5
5 名敌人。我们可以证明，
5
5 名敌人是可以消灭的最大数量。

第
2
2 次增援后，地图变成：
[
1
1
0
1
2
0
0
0
3
]
⎣
⎡
​

1
1
0
​

1
2
0
​

0
0
3
​

⎦
⎤
​
 。此时，对
(
2
,
2
)
(2,2) 方格使用“玉米加农炮”可以消灭
8
8 名敌人。我们可以证明，
8
8 名敌人是可以消灭的最大数量。
示例2
输入
复制
6 6 5
1 1 4 5 1 4
1 9 1 9 8 1
3 5 0 2 3 4
3 1 0 1 1 0
1 9 9 7 0 1
0 9 3 7 2 4
6 4 8
3 2 8
5 1 2
2 5 6
1 2 8
输出
复制
5 3
4 2
4 2
4 2
2 3
说明
在这个样例中：
∙
 
∙第
1
1 次增援后，至多可以消灭
55
55 名敌人。
∙
 
∙第
2
2 次增援后，至多可以消灭
58
58 名敌人。
∙
 
∙第
3
3 次增援后，至多可以消灭
60
60 名敌人。
∙
 
∙第
4
4 次增援后，至多可以消灭
60
60 名敌人。
∙
 
∙第
5
5 次增援后，至多可以消灭
67
67 名敌人。
*
#include<iostream>
#include<vector>
#include<cmath>
using namespace std;
vector<vector<long long>>a;
int n, m, q, x, y, u = -1, v = -1;
long long z, ma = -1;
inline void mh()
{
    int i = max(1, x - 2), b = min(n, x + 2), c = max(1, y - 2), d = min(m, y + 2), j;
    for (; i <= b; i++)
        for (j = c; j <= d; j++)
            if (abs(x - i) + abs(y - j) <= 2)
            {
                a[i][j] += z;
                if (ma < a[i][j])
                    ma = a[i][j], u = i, v = j;
            }
}
int main()
{
    cin >> n >> m >> q;
    a.resize(n + 1);
    for (int i = 0; i <= n; i++)
        a[i].resize(m + 1, 0);
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
        {
            cin >> z;
            if (z)
            {
                x = i, y = j;
                mh();
            }
        }
    for (int k = 0; k < q; k++)
    {
        cin >> x >> y >> z;
        mh();
        cout << u << ' ' << v << endl;//<<ma<<' '
    }

    return 0;
}
*/

/* I √
初华的扭蛋机

题目描述
哇，高达，呀，史莱姆，啊，迪斯科米，芜湖，糖霜苹果。
赌城里一个有
6
6 种小球的扭蛋机，小球的颜色分别是白色（
W
W）、绿色（
G
G）、蓝色（
B
B）、粉色（
P
P）、黄色（
Y
Y）、橙色（
O
O），每种颜色的小球数量都是相等的且无穷多的。
在一次游戏中你有
6
6 枚筹码，对每一枚筹码你可以将其下注在一种颜色区域或将其留在手上（每种颜色区域中可以下注任意枚数筹码），在下注结束后，扭蛋机会进行
3
3 次独立随机抽取，每次等概率地摇出
1
1 颗小球（即每种颜色出现的概率均为
1
6
6
1
​
 ）。
对于每种颜色
c
c 分别计算：设
c
c 对应的区域中筹码数为
x
x 枚，若有
1
1 颗小球的颜色为
c
c ，则获得
2
×
x
2×x 枚筹码；若有
2
2 颗小球的颜色为
c
c ，则获得
3
×
x
3×x 枚筹码；若有
3
3 颗小球的颜色为
c
c ，则获得
10
×
x
10×x 枚筹码。最终我们的筹码数量为在游戏中获得的筹码数量 + 手上的筹码数量。

现在，我们可以用一个长度为
6
6 的字符串
s
s 表示每一枚筹码的下注方式，若
s
s 的第
i
i 个字符为
W
W、
G
G、
B
B、
P
P、
Y
Y、
O
O 之一，表示我们将第
i
i 枚筹码下注在字母对应的颜色区域中；若
s
s 的第
i
i 个字符为
#
#，表示我们将第
i
i 枚筹码留在手中。
例如，
s
s 为
PPP#GO
PPP#GO，摇出的小球颜色分别为
P
P、
G
G、
G
G，由于有
1
1 颗小球颜色为
P
P，我们下注了
3
3 枚筹码，获得
3
×
2
=
6
3×2=6 枚筹码；有
2
2 颗小球颜色为
G
G，我们下注了
1
1 枚筹码，获得
1
×
3
=
3
1×3=3 枚筹码；手上剩余
1
1 枚筹码。因此最终我们的筹码数量为
6
+
3
+
1
=
10
6+3+1=10。

初华觉得没有人比她更懂扭蛋，她需要构造一个下注方案，使得最终筹码数量的期望值最大。
输入描述:
本题不需要处理输入。
输出描述:
在一行上输出一个长度为
6
6 的字符串，表示你所构造的下注方案。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
(无输入)
输出
复制
PPP#GO
说明
样例仅为输出格式参考，不一定是正确答案。
*
#include<iostream>
using namespace std;
int main()
{
    cout << "######" << endl;

    return 0;
}
*/

/* J
立希坐地铁

题目描述
其实，设定上MyGO!!!!!的成员分别是要乐奈、高松灯、千早爱音、长崎素世、椎名立希。
是吗……为什么要告诉我这些？而且为什么是这个顺序？
没什么，只是想让你知道。
西京的城市规划非常标准。地铁线路由
n
n 条水平方向、
n
n 条竖直方向、
n
2
2
n
​
  条环形的地铁构成了一个
n
×
n
n×n 的正方形网格（保证
n
n 一定是偶数），在网格的每一个格点都有一个地铁站。设坐标
(
x
,
y
)
(x,y) 中
x
x 表示行号（自上而下递增），
y
y 表示列号（自左向右递增）：
∙
 
∙水平方向的地铁有东（
E
E，即
y
y 增加）、西（
W
W，即
y
y 减少）两条线路运行；
∙
 
∙竖直方向的地铁有南（
S
S，即
x
x 增加）、北（
N
N，即
x
x 减少）两条线路运行；
∙
 
∙环形的地铁有顺时针（
C
C）、逆时针（
I
I）两条线路运行，第
k
(
1
≤
k
≤
n
2
)
k(1≤k≤
2
n
​
 ) 条环形线路经过所有满足
min
⁡
(
x
,
n
−
x
+
1
,
y
,
n
−
y
+
1
)
=
k
min(x,n−x+1,y,n−y+1)=k 的地铁站，并按方形边界顺时针/逆时针依次连接相邻站点，形成闭环。
每一条线路在相邻两站之间所需的运行时间均为
2
2 个单位时间。同一物理轨道（水平/竖直/环形）的两个相反运行方向被视为两条不同的地铁线路。

https://uploadfiles.nowcoder.com/images/20260203/0_1770058560596/4E83146B63DCD73D8B7F16A5E6DDC049

由于规划原因，西京只有
m
m 个地铁站可以进行站内换乘，第
i
i 个换乘站可以用坐标
(
x
i
,
y
i
)
(x
i
​
 ,y
i
​
 ) 表示。并且因为地铁站修得非常不合理，导致同站不同线路的换乘距离非常长，每次站内换乘都需要步行
1
1 个单位时间。起始站上车和终点站出站不受此限制且无步行代价。
因为每一条地铁线路相邻班次的间隔时间很短，所以我们可以忽略换乘时的等待时间。
只有在
m
m 个指定的换乘站才允许改变当前乘坐的地铁线路。

立希是一位普通游客，她理所当然地完全不认识路。立希现在正在坐标为
(
s
x
,
s
y
)
(s
x
​
 ,s
y
​
 ) 的起点地铁站，她要去坐标为
(
e
x
,
e
y
)
(e
x
​
 ,e
y
​
 ) 的终点地铁站。初始时，立希可以选择任意方向、任意路线的地铁乘坐。
你需要构造一个用时最短的方案使得立希能通过地铁和站内换乘到达终点，或者报告没有可行的方案。
输入描述:
第一行输入两个正整数
n
,
m
(
1
≤
n
≤
2
×
1
0
5
;
 
0
≤
m
≤
2
×
1
0
5
)
n,m(1≤n≤2×10
5
 ;0≤m≤2×10
5
 )，表示地铁线路数量，换乘站数量。
第二行输入四个正整数
s
x
,
s
y
,
e
x
,
e
y
(
1
≤
s
x
,
s
y
,
e
x
,
e
y
≤
n
)
s
x
​
 ,s
y
​
 ,e
x
​
 ,e
y
​
 (1≤s
x
​
 ,s
y
​
 ,e
x
​
 ,e
y
​
 ≤n)，表示起点地铁站
s
s、终点地铁站
e
e 的横纵坐标。
此后
m
m 行，第
i
i 行输入两个正整数
x
i
,
y
i
(
1
≤
x
i
,
y
i
≤
n
)
x
i
​
 ,y
i
​
 (1≤x
i
​
 ,y
i
​
 ≤n)，表示第
i
i 个换乘站的横纵坐标。

数据保证
n
n 一定为偶数，换乘站坐标两两不同，起点地铁站坐标不等于终点地铁站坐标。
输出描述:
如果无法构造方案，直接输出
Impossible!
Impossible!。否则，请参考下方的格式输出。

第一行输出一个整数，表示最短的用时。
第二行输出一个整数
cnt
cnt，表示要乘坐的地铁数量。
第三行输出两个整数
s
x
,
s
y
s
x
​
 ,s
y
​
 ，表示立希乘坐地铁的起点站
s
s 的横纵坐标。
此后
2
×
cnt
2×cnt 行：
∙
 
∙第一行输出一个字符
ch
(
ch
∈
[
E
,
W
,
S
,
N
,
C
,
I
]
)
ch(ch∈[E,W,S,N,C,I])，表示立希乘坐地铁的方向。
∙
 
∙第二行输出两个整数
p
x
,
p
y
p
x
​
 ,p
y
​
 ，表示立希乘坐地铁的换乘/终点站
p
p 的横纵坐标。

注意：除最后一段外，每段乘车的终点
p
p 必须是一个可换乘站，地铁乘坐方向存在且可以按顺序连接前后两个地铁站，不允许同站同方向换乘，最后一行出站坐标必须为
e
x
,
e
y
e
x
​
 ,e
y
​
 。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2 0
1 1 2 2
输出
复制
4
1
1 1
C
2 2
说明
在这个样例中，一种最优方案为：
∙
 
∙从
s
s 走顺时针环线花费
2
2 个单位时间到达
p
1
=
(
1
,
2
)
p
1
​
 =(1,2)，
∙
 
∙再从
p
1
p
1
​
  走顺时针环线花费
2
2 个单位时间到达
p
2
=
(
2
,
2
)
p
2
​
 =(2,2)。
由于不需要换乘，因此总花费时间为
4
4 个单位时间。可以证明，这是最优方案。

将输出中的字母
C
C 改成
I
I 也是合法答案。
示例2
输入
复制
6 1
1 1 4 4
1 4
输出
复制
13
2
1 1
E
1 4
S
4 4
说明
这个样例的地铁线路如题面中的图片所示。一种最优方案为：
∙
 
∙从
s
s 走东方向水平线路花费
6
6 个单位时间到达
p
1
=
(
1
,
4
)
p
1
​
 =(1,4)，
∙
 
∙站内换乘，由东方向水平线路换乘至南方向竖直线路花费
1
1 个单位时间，
∙
 
∙再从
p
1
p
1
​
  走南方向竖直线路花费
6
6 个单位时间到达
p
2
=
(
4
,
4
)
p
2
​
 =(4,4)。
总共花费
13
13 个单位时间。可以证明，这是最优方案。
示例3
输入
复制
6 1
1 1 4 5
1 4
输出
复制
Impossible!
*/
