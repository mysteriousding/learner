//链接：https://ac.nowcoder.com/acm/contest
//来源：牛客网
/* A  √
本场比赛灵感来源于树状数组出题组

题目描述
怎么出一场区域赛题目？简单，放 2 道签到题和 8 道构造题就行了。
老八提出了八氏二分法，在数组中，对于第
𝑥
x 个数字
𝑎
𝑥
a
x
​
 ，如果其他数字中有至少
80
%
80% 的数字小于等于
𝑎
𝑥
a
x
​
 ，则将第
𝑥
x 个数字分在 A 组，否则分在 B 组。
求 A 组中的数字之和。
输入描述:
第一行输入一个正整数
𝑛
(
2
≤
𝑛
≤
1
0
3
)
n(2≤n≤10
3
 )，表示数组大小。
第二行输入
𝑛
n 个整数
𝑎
1
,
𝑎
2
,
…
,
𝑎
𝑛
(
1
≤
𝑎
𝑖
≤
1
0
3
)
a
1
​
 ,a
2
​
 ,…,a
n
​
 (1≤a
i
​
 ≤10
3
 )，表示数组。
输出描述:
输出一个整数表示答案。
示例1
输入
复制
6
1 1 4 5 1 4
输出
复制
13
说明
对于这组数据：
∙
 
∙对于第一个数字，在除了它以外的
5
5 个数字中，只有
2
2 个数字小于等于它，不到
80
%
80%，因此分在 B 组；
∙
 
∙对于第二个数字，只有
2
2 个数字小于等于它，不到
80
%
80%，因此分在 B 组；
∙
 
∙对于第三个数字，只有
4
4 个数字小于等于它，达到
80
%
80%，因此分在 A 组；
∙
 
∙对于第四个数字，只有
5
5 个数字小于等于它，达到
80
%
80%，因此分在 A 组；
∙
 
∙对于第五个数字，只有
2
2 个数字小于等于它，不到
80
%
80%，因此分在 B 组；
∙
 
∙对于第六个数字，只有
4
4 个数字小于等于它，达到
80
%
80%，因此分在 A 组。
综上，A 组中的数字之和为
4
+
5
+
4
=
13
4+5+4=13。
*
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main()
{
    int n, m, h;
    long long num = 0;
    cin >> n;
    vector<int>a(n + 1);
    m = n * 0.8 + 1;
    for (int i = 1; i <= n; i++)
        cin >> a[i];
    sort(a.begin(), a.end());
    h = a[m];
    for (int i = n; a[i] >= h; i--)
        num += a[i];
    cout << num << endl;

    return 0;
}
*/

/* B √
构造部落

题目描述
由于残暴的文字狱，后续题目名字“构造王国”等被迫改名。
部落时代对于我们已经非常遥远了，因此部落时代的时间我们很难精确的描述。
我们已知部落时代有
n
n 位首领，第
1
1 位部落首领在位的第
1
1 年为公元
s
s 年，还知道第
i
i 位首领在位时间
t
i
t
i
​
 ，在此我们假设每一位首领的在位时间都恰好为整数年。
n
n 位首领按编号顺序连续在位，即第
i
i 位首领在位结束后的次年，第
i
+
1
i+1 位首领立即即位。
现在，考古学家发现了
q
q 件文物，每件文物上记录了在第
x
x 位首领在位的第
y
y 年发生的事件，你需要帮助考古学家确定每个事件发生在公元多少年。
输入描述:
第一行输入三个整数
n
,
q
,
s
(
1
≤
n
,
q
≤
2
×
1
0
5
;
 
−
1
0
9
≤
s
≤
1
0
9
)
n,q,s(1≤n,q≤2×10
5
 ;−10
9
 ≤s≤10
9
 )，表示部落首领数量，文物数量，第一位部落首领在位的第一年的公元年份。
第二行输入
n
n 个正整数
t
1
,
t
2
,
…
,
t
n
(
1
≤
t
i
≤
5
×
1
0
3
)
t
1
​
 ,t
2
​
 ,…,t
n
​
 (1≤t
i
​
 ≤5×10
3
 )，表示每一位首领在位的年数。
此后
q
q 行，第
i
i 行输入两个整数
x
i
,
y
i
(
1
≤
x
i
≤
n
;
 
1
≤
y
i
≤
t
x
i
)
x
i
​
 ,y
i
​
 (1≤x
i
​
 ≤n;1≤y
i
​
 ≤t
x
i
​

​
 ) 表示第
i
i 件文物记录的是第
x
i
x
i
​
  位首领在位的第
y
i
y
i
​
  年。
输出描述:
对于每一件文物，新起一行输出一个整数，表示该事件发生在公元多少年。
示例1
输入
复制
6 3 0
1 1 4 5 1 4
1 1
3 3
4 4
输出
复制
0
4
9
说明
在这个样例中：
∙
 
∙第一位首领在位的第
1
1 年为公元
0
0 年；
∙
 
∙第二位首领在位的第
1
1 年为公元
1
1 年；
∙
 
∙第三位首领在位的第
1
1 年为公元
2
2 年，在位的第
3
3 年为公元
4
4 年；
∙
 
∙第四位首领在位的第
1
1 年为公元
6
6 年，在位的第
4
4 年为公元
9
9 年。
示例2
输入
复制
6 4 8
1 1 4 5 1 4
1 1
3 3
4 4
4 5
输出
复制
8
12
17
18
*
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main()
{
    int n, m, h, x, y;
    cin >> n >> m;
    vector<int>a(n + 2);
    cin >> a[1];
    for (int i = 2; i < n + 2; i++)
    {
        cin >> h;
        a[i] = a[i - 1] + h;
    }
    for (int i = 0; i < m; i++)
    {
        cin >> x >> y;
        cout << a[x] + y - 1 << endl;
    }

    return 0;
}
*/

/* C √
墨提斯的排列

题目描述
排列相邻位异或起来求和——和异位！
萨莉亚——和意味！
墨提斯想构造一个长度为
2
n
2
n
  的排列
p
0
,
p
1
,
…
,
p
(
2
n
−
1
)
p
0
​
 ,p
1
​
 ,…,p
(2
n
 −1)
​
 ，使得相邻两项异或值之和最小。换句话说，最小化：

∑
i
=
1
2
n
−
1
(
p
i
−
1
⊕
p
i
)
i=1
∑
2
n
 −1
​
 (p
i−1
​
 ⊕p
i
​
 )

可以证明，最优解一定存在。

【名词解释】
长度为
n
n 的排列：由
0
,
1
,
…
,
n
−
1
0,1,…,n−1 这
n
n 个整数、按任意顺序组成的数组（每个整数均恰好出现一次）。例如，
{
1
,
2
,
0
,
4
,
3
}
{1,2,0,4,3} 是一个长度为
5
5 的排列，而
{
0
,
1
,
1
}
{0,1,1} 和
{
0
,
2
,
3
}
{0,2,3} 都不是排列，因为前者存在重复元素，后者包含了超出范围的数。
⊕
⊕：指位运算中的按位异或（Bitwise XOR），对两个整数的二进制表示按位进行异或运算。如果您需要更多位运算相关的知识，可以参考 OI-Wiki的相关章节。
输入描述:
输入一个正整数
n
(
1
≤
n
≤
18
)
n(1≤n≤18)。
输出描述:
在一行中输出
2
n
2
n
  个整数，表示构造的排列。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
1
输出
复制
0 1
说明
在这个样例中，输出
{
0
,
1
}
{0,1} 和
{
1
,
0
}
{1,0} 都是合法的答案。
*
#include<iostream>
using namespace std;
int main()
{
    int n, count;
    cin >> n;
    count = 1 << n;
    for (int i = 0; i < count; i++)
        cout << (i ^ (i >> 1)) << ' ';

    return 0;
}
*/

/* D
东风谷早苗与博丽灵梦

题目描述
这个国家的人一般都体型偏瘦而且人口老龄化严重，为什么呢？
有一个长度为
x
x 的线段，早苗站在线段左端点，灵梦站在线段右端点。早苗每秒可以向右移动
a
a 个单位长度，灵梦每秒可以向左移动
s
s 个单位长度。早苗和灵梦每秒可以分别选择移动、不移动，一旦选择移动，必须完整走完这一秒而不能中途停，并且移动过程中不能超出线段端点。
请构造一个方案，使得在某一秒结束时，两人恰好处于同一坐标（即相遇），且用时最短。方案仅需给出两个非负整数
c
1
,
c
2
c
1
​
 ,c
2
​
 ，分别表示早苗的移动次数和灵梦的移动次数，且最小化
max
⁡
(
c
1
,
c
2
)
max(c
1
​
 ,c
2
​
 )。如果不存在符合条件的方案，直接输出
No
No。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≤
T
≤
1
0
4
)
T(1≤T≤10
4
 ) 代表数据组数，每组测试数据描述如下：

在一行上输入三个正整数
x
,
a
,
s
(
1
≤
x
,
a
,
s
≤
1
0
18
)
x,a,s(1≤x,a,s≤10
18
 ) ，表示线段长度，早苗移动速度，灵梦移动速度。
输出描述:
对于每一组测试数据，新起一行。如果不存在符合条件的方案，直接输出
No
No，否则：
∙
 
∙第一行输出
Yes
Yes；
∙
 
∙第二行输出两个非负整数
c
1
,
c
2
c
1
​
 ,c
2
​
 ，分别表示早苗、灵梦的移动次数；

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2
2 1 1
1 2 2
输出
复制
Yes
1 1
No
说明

*
#include<iostream>
using namespace std;
int main()
{
    long long t, s, x, y, u, v, l, i;
    bool k;
    cin >> t;
    while (t--)
    {
        u = v = -1;
        cin >> s >> x >> y;
        k = x < y;
        if (k)x += y, y = x - y, x -= y;
        if (y)
            for (i = s / x; i >= 0; i--)
            {
                l = s - x * i;
                if (!(l % y))
                {
                    u = i, v = l / y;
                    break;
                }
            }
        else if (x && !(s % x))
            u = s / x, v = 0;
        if (u != -1)
        {
            cout << "Yes" << endl;
            if (x == y)cout << (long long)(u / 2.0 + 0.5) << ' ' << u / 2 << endl;
            else if (k)cout << v << ' ' << u << endl;
            else cout << u << ' ' << v << endl;
        }
        else cout << "No" << endl;
    }

    return 0;
}
*/

/* E
立希的扫雷构造

题目描述
你知道吗，鱿鱼不仅能做鱿鱼丝，还能做肥皂呢。
扫雷是一款经典游戏，游戏中有一张网格图，每一个格子要么是“地雷”、要么是“空地”。定义一个“空地”的危险值为周围
8
8 个格子中“地雷”的个数；“地雷”格子的危险值为
0
0。
立希为了狩猎鱿鱼，现在她需要在一个大小为
n
×
m
n×m 的网格图中布置
k
k 个地雷，使得所有格子的危险值之和最大。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≤
T
≤
1
0
4
)
T(1≤T≤10
4
 ) 代表数据组数，每组测试数据描述如下：

在一行上输入三个整数
n
,
m
,
k
(
1
≤
n
,
m
≤
9
;
 
0
≤
k
≤
n
×
m
)
n,m,k(1≤n,m≤9;0≤k≤n×m)，表示网格图的长宽、地雷数量。
输出描述:
对于每一组测试数据，第一行输出一个整数，表示所有网格的危险值之和；此后
n
n 行，每行输出一个长度为
m
m，仅由字符
.
. 和
*
* 组成的字符串
s
i
,
1
s
i
,
2
⋯
s
i
,
m
s
i,1
​
 s
i,2
​
 ⋯s
i,m
​
 ，表示你所构造的网格图。其中，第
j
j 个字符
s
i
,
j
=
*
s
i,j
​
 =* 表示第
i
i 行第
j
j 列的格子为“地雷”；否则表示为“空地”。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2
3 3 1
3 3 3
输出
复制
8
...
.*.
...
14
...
***
...
说明
对于第一组测试数据，每一个网格的危险值为：
[
1
1
1
1
0
1
1
1
1
]
⎣
⎡
​

1
1
1
​

1
0
1
​

1
1
1
​

⎦
⎤
​
 ，总危险值为
8
8。

对于第二组测试数据，每一个网格的危险值为：
[
2
3
2
0
0
0
2
3
2
]
⎣
⎡
​

2
0
2
​

3
0
3
​

2
0
2
​

⎦
⎤
​
 ，总危险值为
14
14。
*/

/* F √
爱音的01串构造

题目描述
“这里是天堂吗？”——0.5如是说。
爱音想要构造一个由
a
a 个
0
0 和
b
b 个
1
1 组成的 01 字符串，且使得这个 01 字符串所有非空连续子串的
mex
⁡
mex 之和最大。

在本题中，01 串的
mex
⁡
mex 定义为：字符串最小未出现的非负整数。例如，
mex
⁡
(
"0"
)
=
1
mex("0")=1、
mex
⁡
(
"1"
)
=
0
mex("1")=0、
mex
⁡
(
"1100"
)
=
2
mex("1100")=2。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≤
T
≤
1
0
5
)
T(1≤T≤10
5
 ) 代表数据组数，每组测试数据描述如下：

在一行上输入两个整数
a
,
b
(
0
≤
a
,
b
≤
1
0
5
;
 
0
<
a
+
b
)
a,b(0≤a,b≤10
5
 ;0<a+b)，表示字符串中
0
0 的个数、
1
1 的个数。

除此之外，保证单个测试文件的
a
a 之和、
b
b 之和均不超过
2
×
1
0
5
2×10
5
 。
输出描述:
对于每一组测试数据，新起一行输出一个 01 串，表示你所构造的字符串。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2
1 1
2 1
输出
复制
01
010
说明
对于第一组测试数据，字符串
"01"
"01" 和
"10"
"10" 都是合法的答案。具体地，对于字符串
"01"
"01"，其所有非空连续子串为：
∙
 
∙
"0"
"0"，
mex
⁡
=
1
mex=1；
∙
 
∙
"1"
"1"，
mex
⁡
=
0
mex=0；
∙
 
∙
"01"
"01"，
mex
⁡
=
2
mex=2。
总和为
1
+
0
+
2
=
3
1+0+2=3。
示例2
输入
复制
1
2 1
输出
复制
010
*
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int t, n, m, x, y;
    char a, b;
    string s;
    cin >> t;
    while (t--)
    {
        s = "";
        cin >> n >> m;
        if (n >= m)a = '0', b = '1';
        else n += m, m = n - m, n -= m, a = '1', b = '0';
        x = n / (m + 1), y = m - n % (m + 1);
        for (int i = 0; i < x; i++)
            s += a;
        for (int i = 0; i <= m; i++)
        {
            if (i)cout << b;
            cout << s;
            if (i == y)s += a;
        }
        cout << endl;
    }

    return 0;
}
*/

/* G
真白的幻觉

题目描述
这道题很简单，只需要两只手各举起一个数字就可以了。
mashiro 吃菌子中毒时发现将数字按位累乘非常好玩，于是她决定好好研究一下。

定义
f
(
x
)
f(x) 为将
x
x 的每一位数字相乘的结果，例如
f
(
21
)
=
2
×
1
=
2
f(21)=2×1=2、
f
(
42
)
=
4
×
2
=
8
f(42)=4×2=8、
f
(
84
)
=
8
×
4
=
32
f(84)=8×4=32、
f
(
114514
)
=
80
f(114514)=80 等等。
定义
g
(
x
)
g(x) 为
x
:
=
f
(
x
)
(
x
≠
f
(
x
)
)
x:=f(x)(x

​
 =f(x)) 可以执行的次数，即重复执行操作“当
x
≠
f
(
x
)
x

​
 =f(x) 时令
x
:
=
f
(
x
)
x:=f(x)”，直到出现
x
=
f
(
x
)
x=f(x) 为止需要的执行次数。

构造两个不超过
1
0
18
10
18
  的正整数
a
,
b
a,b，最大化
g
(
a
)
+
g
(
b
)
g(a)+g(b) 的值，且
f
(
a
)
≠
f
(
b
)
f(a)

​
 =f(b)。
输入描述:
本题不需要处理输入。
输出描述:
在一行上输出两个正整数，表示答案。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
（无输入）
输出
复制
1 23
说明
样例仅供输出参考。
我没要求你永远都出很好的题，我不是恶魔。
可是，输出两个整数什么意思？你的出题观念怎么了？你才21岁吧？再这样下去，你42岁输出四个数，84岁输出八个数，最后就变成八常大数了。
作为正义做题人，我可能得打败你。真的。
备注:

*/

/* H √


*/
