/*
问题描述
蓝桥杯全国总决赛的颁奖典礼结束后，小蓝被分配了一个任务——录入部分获奖选手的奖项信息。

他用 "G"、"G1"、"G2"、"G3"、"GG"、"1"、"2"、"3" 这些字符串分别表示国特、国一、国二、国三、国优、省一、省二、省三等级。
为了提高效率，小蓝写了个 Python 脚本来自动录入这些字符串。但是，小蓝过于粗心，竟忘记在各个奖项代码之间加分隔符！
这就导致运行完脚本后，所有的奖项信息都挤在一起变成了一串长长的字符串，例如 "GG123G1G2G3123G1"。

小蓝的头发都快掉光了！他知道这部分选手中，每个奖项都至少有一位获奖选手，且国特只有一位。
现在，他对着这串乱糟糟的字符串S，想知道这部分选手中最多可能有多少位选手获得了国一("G1")。

对此，请你帮帮可怜的小蓝，找出字符串 S 中最多可能有多少个 "G1"。

输入格式
输入一个字符串S，包含了所有的奖项信息，字符串长度不超过2×10^3。

S 由 "G"、"G1"、"G2"、"G3"、"GG"、"1"、"2"、"3" 组成，保证S 是合法的。

输出格式
输出一个整数，表示字符串S 中最多可能包含的 "G1" 的个数。

样例输入
GG123GG2G1G2G3123
copy
样例输出
2
*/
#include <iostream>
#include<string>
using namespace std;
int main()
{
    string n;
    cin >> n;
    int i, g = 0, gg = 0, g1 = 0, j = 0;
    int k[3] = { 0 }, k0[3] = { 0 };;
    while (n[i] != '\0')
    {
        if (n[i] == 'G')
        {
            g++;
            if (n[i + 1] == '1')g1++;
            if (n[i + 1] == 'G')
            {
                gg++;
                if (n[i + 2] >= '1' && n[i + 2] <= '3')k[n[i + 2] - '1']++;
            }
        }
        if (n[i] == 'G')
        {
            if (n[i + 1] >= '1' && n[i + 1] <= '3')k0[n[i + 2] - '1']++;
        }
        if (n[i] == '1')j++;
        i++;
    }
    cout << g1 - ((g1 == j) ? 1 : 0) - ((k[0] == k0[0] && k[1] == k0[1] && k[2] == k0[2]) ? 1 : 0) << endl;

    return 0;
}
