/*
问题描述
双十一前夕，小蓝凭借高超的技术手段（其实是发现了系统的 BUG），薅到了无数张面值为M 元的无门槛、可叠加使用的代金券。
这意味着只要购买商品的总价是M 的倍数，就能将商品免费带回家。小蓝的购物车里已经塞满了各种心仪的宝贝，总价为N 元，恰好M 的倍数。
只是，他觉得这样的薅羊毛还不够极致。于是，他决定在确认订单时，修改总价（可以在N 的开头、结尾或中间插入一个新数字）。
例如，如果原总价N 是123 元，那么他可以修改成4123 元，1243 元，1234 元等等。虽然实际支付的金额仍然是0 元（使用无限的代金券），但更高的总价意味着可以获得更高的积分、更高级的会员等级。

不过，小蓝也担心修改后的总价过高会触发系统的安全警报，导致 BUG 被修复。
因此，他想找到一个比N 大的最小数字，这个数字是由在N 的数字之间（含头尾）插入一个数字构成的，并且仍然是M 的倍数。
这样，他就能在最大化 BUG 收益的同时，最小化被发现的风险。

现在，请你帮小蓝找出这个最小的数字。

输入格式
第一行包含一个整数，表示测试用例的数量。

接下来的t 行，每行包含两个整数N,M（1≤M≤N≤10^9，保证N 是M 的倍数），分别表示小蓝购物车里商品的初始总价和代金券的面值。

输出格式
对于每组测试数据，输出一个整数，表示小蓝能够构造出的比N 大的最小数字，且该数字是M 的倍数。如果不存在这样的数字，则输出−1。

样例输入
2
4 2
6 3

样例输出
14
36
*/
#include <iostream>
#include<vector>
#include<string>
using namespace std;
int main()
{
    int k;
    long long n, m;
    cin >> k;
    vector<string>E;
    int o = 0;
    for (int i = 0; i < k; i++)
    {
        cin >> n >> m;
        string n0 = to_string(n);
        E.resize(10 * (n0.size() + 1), "");
        o = 0;
        for (int j = 0; j < 10; j++)
        {
            for (int p = 0; p <= n0.size(); p++)
            {
                if (p == 0 && j == 0)p++;
                string h = n0.substr(0, p) + to_string(j) + n0.substr(p);
                long long h0 = stoll(h);
                if (h0 % m == 0)
                    E[o++] = h;
            }
        }
        if (o == 0)cout << -1 << endl;
        else
        {
            string min = E[0];
            for (int i = 0; i < o; i++)
            {
                if (min > E[i])min = E[i];
                E[i] = "";
            }

            cout << min << endl;
        }

    }

    return 0;
}
