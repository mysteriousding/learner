/*
召唤帝皇侠【算法赛】

问题描述
暗影再次笼罩地球，邪恶的影界势力卷土重来，企图让世界陷入永恒的黑暗。
为了对抗这股强大的黑暗势力，最强铠甲——帝皇侠，必须被唤醒！

召唤帝皇侠需要消耗巨大的能量，这些能量以光子为单位进行计算。
目前，ERP 研究室的能量核心储存着 X 个单位的光子能量。
只是，帝皇侠的召唤仪式非常严格，并非任何能量值都能唤醒他。
只有当释放的能量值 N（1≤N≤X） 是 ⌊N⌋ 的整数倍时，才能与光影石产生共鸣，成功召唤帝皇侠。

情况紧急，敌人步步紧逼。美真必须预先计算好所有符合条件的能量值 N 的总和，以便在激烈的战斗中，根据能量核心剩余的能量，迅速判断是否存在符合条件的能量值。

作为美真的助手，请你帮助美真计算出所有符合条件的能量值 N 的总和，并对 998244353 取模。

输入格式
第一行给出测试用例的个数 T（ 1≤T≤10^5  ）。

接下来 T 行，每行包含一个整数 X（ 1≤X≤10^18  ），表示能量核心储存的光子能量。

输出格式
对于每个测试用例，输出一个整数，表示所有符合条件的能量值 N 的总和，并对 998244353 取模。

样例输入
2
3
5

样例输出
6
10

样例说明
在第一个测试用例中，满足条件的 N 有：1,2,3，总和为 6。

在第二个测试用例中，满足条件的 N 有：1,2,3,4，总和为 10。
*/
// #include <iostream>
// using namespace std;
// int main()
// {
//   long long n,m,num;
//   cin>>n;
//   while(n--)
//   {
//     cin>>m;
//     num=0;
//     for(int i=1;i*i<=m;i++)
//     {
//       num+=i*i;
//       if(i*(i+1)<=m)num+=i*(i+1);
//       if(i*(i+2)<=m)num+=i*(i+2);
//       num%=998244353;
//     }
//     cout<<num<<endl;
//   }

//   return 0;
// }



#include <iostream>
#include <cmath>
using namespace std;
const int M = 998244353;

int main() {
    int t;
    cin >> t;
    while (t--) {
        long long x;
        cin >> x;
        long long n = sqrt(x + 1) - 1;
        long long ans = n * (n + 1) % M * (n + 2) % M;
        int i = 0;
        while ((n + 1) * (n + 1 + i) <= x)
            ans += (n + 1) * (n + 1 + i), i++;
        cout << ans % M << '\n';
    }

    return 0;
}