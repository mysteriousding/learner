//链接：https://ac.nowcoder.com/acm/contest/120563
//来源：牛客网
/* A √
宙天

题目描述
小红正在探索宇宙的奥秘，她认为某些数字承载着特殊的意义。
小红定义一个正整数 x 为「终极答案」，当且仅当它能表示为两个连续自然数的乘积。
形式化的，若存在自然数 k，满足 x=k×(k+1)，则称 x 为「终极答案」。
给定一个正整数 x，请你帮小红判断它是否是一个「终极答案」。

输入描述:
在一行上输入一个整数 x(1≦x≦100)。

输出描述:
如果 x 是一个「终极答案」，输出 YES；否则输出 NO。

示例1
输入
42

输出
YES

说明
在这个样例中，x=42=6×7。
由于 6 和 7 是两个连续的自然数，因此 42 是一个「终极答案」。


示例2
输入
5

输出
NO
*
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int n, k;
    cin >> n;
    k = pow(n, 0.5);
    cout << (n == k * ++k ? "YES" : "NO") << endl;

    return 0;
}
*/

/* B √
Random

题目描述
小红拿到了一个长为 n 的数组 a1 ,a2 ,…,an 。
 她想要选择其中两个不同位置的元素，要求这两个元素的最大公约数大于 1，请你帮帮她。
特殊的，保证数组元素在 [1,10^9] 范围内独立均匀随机生成。

【名词解释】
最大公约数（gcd）：指两个或多个整数共有约数中最大的一个。
例如，12 和 30 的公约数有 1,2,3,6，其中最大的约数是 6，因此记作 gcd(12,30)=6。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^4 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数 n(1≦n≦2×10^5 )，代表数组长度。
第二行输入 n 个整数 a1 ,a2 ,…,an (1≦ai≦10^9 )，代表数组元素。

除此之外，保证单个测试文件的 n 之和不超过 2×10^5 。

输出描述:
对于每组测试数据，如果不存在符合要求的两个元素，直接输出 −1；否则，在一行上输出两个整数，代表选中的两个元素的值。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。

示例1
输入
2
5
101770993 7791101 39239295 480041099 460611962
5
981262894 280102212 13579679 112334424 10169419

输出
-1
981262894 280102212

备注:
在几乎全部的情况下，PyPy 的运行速度优于 Python，我们建议您选择对应版本的 PyPy 进行提交、而不是 Python。
*
#include<iostream>
#include<vector>
using namespace std;
bool gcd(int x, int y)
{
    int z = 1;
    while (z)
    {
        z = x % y;
        x = y;
        y = z;
    }
    return x != 1;
}
int main()
{
    int t, n;
    bool v;
    vector<int>a;
    cin >> t;
    while (t--)
    {
        v = 1;
        cin >> n;
        a.resize(n);
        for (int i = 0; i < n; i++)
            cin >> a[i];
        for (int i = 0; v && i < n - 1; i++)
            for (int j = i + 1; v && j < n; j++)
                if (gcd(a[i], a[j]))
                {
                    v = 0;
                    cout << a[i] << " " << a[j] << endl;
                }
        if (v)cout << -1 << endl;
    }

    return 0;
}
*/

/* C
Inverted World

题目描述
小芳拿到了一个仅由字符 0 和 1 组成的长为 n 的字符串 s，他可以进行任意次如下操作：
∙选择 s 的一个非空子序列[1] ，该子序列任意两个相邻元素都不相同，将该子序列进行 01 反置[2] 。
小芳想知道，最少需要多少次操作才能使得 s 中任意两个相邻元素都不相同？

【名词解释】
子序列[1] ：从原序列中删除任意个（可以为零，也可以为全部）元素，且保持剩余元素相对顺序不变得到的新序列。
01 反置[2] ：同时将字符串中的 0 变成 1，1 变成 0。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^4 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数 n(1≦n≦2×10^5 )，代表字符串长度。
第二行输入一个长为 n，仅由字符 0 和 1 构成的字符串 s。

除此之外，保证单个测试文件的 n 之和不超过 2×10^5 。

输出描述:
对于每组测试数据，新起一行输出一个整数，代表所需要的最少操作次数。

示例1
输入
2
5
11101
5
11100

输出
1
1

说明
对于第一组测试数据，一种可行的操作方法为 11101→10101。
对于第二组测试数据，一种可行的操作方法为 11100→10101 。
*
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int t, n;
    string s;
    char f;
    bool v;
    cin >> t;
    while (t--)
    {
        v = 1;
        cin >> n;
        cin.ignore();
        getline(cin, s);
        for (int i = 1; i < n; i++)
            if (s[i] != s[i - 1])
            {
                v = 0;
                break;
            }
        if (v)
        {
            cout << 0 << endl;
            continue;
        }
        v = 1;
        f = s[0];
        for (char c : s)
            if (c != f)
            {
                v = 0;
                break;
            }
        cout << 1 + v << endl;
    }

    return 0;
}
*/

/* D
系ぎて

题目描述
小红正在一块 n 行 m 列的电路板上修复信号。
电路板的每个格点上可能标记着数字 0、1 或 2。
其中，标记为 1 的格点恰好有两个，标记为 2 的格点也恰好有两个，其余格点均为 0。

小红需要规划两条路径，分别连接两个 1 信号点和两个 2 信号点。
一条合法的路径定义为：
∙ 路径由一系列相邻的格子组成（上、下、左、右）。
∙ 两条路径不能经过同一个格子。
∙ 每条路径不能经过不属于该路径的信号点（例如，连接 1 的路径不能经过任何标记为 2 的格点）。
∙ 路径可以经过标记为 0 的格点，每个 0 格点最多只能被一条路径使用一次。

请你帮小红判断是否存在这样的两条路径。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^4 ) 代表数据组数，每组测试数据描述如下：

第一行输入两个整数 n,m(2≦n,m≦10^5 )，表示网格的行数和列数。
接下来 n 行，每行输入一个长度为 m 的字符串，由字符 0、1、2 组成，表示电路板的每个格点上的标记。
保证 1 和 2 的数量恰好为 2。

除此之外，保证单个测试文件的 n×m 之和不超过 10^5 。

输出描述:
对于每组测试数据，新起一行输出 YES 或 NO，表示是否存在满足要求的两条路径。

示例1
输入
3
2 2
12
21
2 2
11
22
3 3
010
212
000

输出
NO
YES
YES

说明
对于第一组测试数据，两个 1 和两个 2 呈对角分布，连接其中一对必会阻断另一对，无法构造不相交路径。

对于第二组测试数据，两个 1 都在第一行，两个 2 都在第二行，可以分别在各自行内水平连接。

对于第三组测试数据，连接了两个 1 后，两个 2 可以从下方绕成一个连通的路径。
*/

/* E
躯树の墓守

题目描述
小芳最近学会了最小生成树，现在她想要用几道题来检验自己。
请你生成一个包含 n 个点，m 条边，对于每条边的边权 wi  都有 wi ∈[1,m] 且边权互不相同的无向简单连通图[1] ，它的最小生成树[2] 的边权之和恰好为 k。
点的编号为 1 到 n。

【名词解释】
简单连通图[1] ：指不包含自环（连接节点自身的边）和重边（两个节点之间存在多条边）、且任意两个顶点之间都存在路径相连的图。
最小生成树[2] ：对于一张由 n 个节点构成的连通图，选出 n−1 条边将所有节点连通，且使得这 n−1 条边的权重之和最小，这样的结构称为最小生成树。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数bT(1≦T≦10^4 ) 代表数据组数，每组测试数据描述如下：

第一行输入三个整数 n,m,k(1≦n≦2×10^5 ;n−1≦m≦min(2×10^5 ,n(n−1)/2 );1≦k≦10^9 )。

除此之外，保证单个测试文件的 n 之和、m 之和均不超过 2×10^5 。

输出描述:
对于每组测试数据，如果不存在符合要求的图，直接输出 NO；否则：
∙第一行输出 YES；
∙此后 m 行，第 i 行输出三个整数 ui ,vi ,wi ，表示第 i 条边连接点 ui ,vi ，边权为 wi 。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。
注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。

示例1
输入
2
4 5 6
3 2 4

输出
YES
1 2 1
2 3 2
3 4 3
3 1 4
4 2 5
NO
*/

/* F
Energy Synergy Matrix

题目描述
小红和小紫围绕小小红展开博弈。

有一个 2 行 n 列的网格，所有格子初始为空。
小小红初始在左上角 (1,1)。
每次可以向上下左右相邻格子移动一步（不能走到障碍格，也不能走出网格）。
小小红需要到达第 n 列的任意一个空格子，并且总是选择最短步数的路径。

小红和小紫进行博弈（小红先手），轮流执行操作：
∙选择一个当前为空且不为起点的格子放置障碍，使小小红无法进入该格子；
∙要求放置后，从起点 (1,1) 仍然存在一条路径能够到达第 n 列的某个空格子。
若当前不存在满足要求的格子可放置障碍，则博弈结束。

两人都按最优策略行动：小红希望最终最短步数尽量小，小紫希望最终最短步数尽量大。
博弈结束后，小小红从起点出发。请输出她到达第 n 列所需的最少步数。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^4 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数 n(1≦n≦10^9 )，表示网格的列数。

输出描述:
对于每组测试数据，新起一行输出一个整数，代表最终小小红的移动次数。

示例1
输入
2
1
5

输出
0
5
*/

/* G √
スピカの天秤

题目描述
小红有一个天平，天平的左侧有 n 个砝码，砝码的重量用数组 a 表示；右侧有 m 个砝码，砝码的重量用数组 b 表示。
我们认为天平有三种状态：
∙左侧的重量大于右侧。
∙左侧的重量等于右侧。
∙左侧的重量小于右侧。
现在小红想知道，想要改变天平的状态，她最少需要拿走多少个砝码？

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^4 ) 代表数据组数，每组测试数据描述如下：

第一行输入两个整数 n,m(1≦n,m≦10^5 )，表示天平左侧的砝码数量、天平右侧的砝码数量。
第二行输入 n 个整数 a1 ,a2 ,…,an (1≦ai≦10^9 )，表示天平左侧的砝码重量。
第三行输入 m 个整数 b1 ,b2 ,…,bm (1≦bi≦10^9 )，表示天平右侧的砝码重量。

除此之外，保证单个测试文件的 n 之和、m 之和不超过 2×10^5 。

输出描述:
对于每组测试数据，新起一行输出一个整数，代表最少需要拿走的砝码数量。

示例1
输入
2
1 1
10
10
1 4
1
1 1 1 1

输出
1
3

说明
对于第一组测试数据，小红可以拿走任意一个砝码。

对于第二组测试数据，小红需要从天平右侧拿走三个砝码。
*
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
int main()
{
    long long t, n, m, nn, nm, x, y, z;
    vector<int>a, b, * p;
    cin >> t;
    while (t--)
    {
        nn = nm = y = 0;
        cin >> n >> m;
        a.resize(n);
        b.resize(m);
        for (int i = 0; i < n; i++)
            cin >> a[i], nn += a[i];
        for (int i = 0; i < m; i++)
            cin >> b[i], nm += b[i];
        x = nn > nm ? (p = &a, z = n, nn - nm) : (p = &b, z = m, nm - nn);
        sort(p->begin(), p->end());
        for (int i = z - 1; i >= 0; i--)
        {
            x -= (*p)[i];
            y++;
            if (x <= 0)
            {
                cout << y << endl;
                break;
            }
        }
    }

    return 0;
}
*/

/* H
Tic Tac DREAMIN’

题目描述
小红在二维平面地图上标记了两个关键点 A(xa ,ya) 和 B(xb ,yb)。
她现在需要在 x 轴上寻找一个锚点 O(x,0)，使得以 A,B,O 为顶点的三角形面积恰好等于 2。
请你帮小红判断是否存在符合条件的锚点横坐标 x。
如果存在，请找出一个符合条件的 x。

输入描述:
第一行输入两个整数 xa ,ya (−10^4 ≦xa ,ya ≦10^4 )，代表点 A 的坐标。
第二行输入两个整数 xb ,yb (−10^4 ≦xb ,yb ≦10^4 )，代表点 B 的坐标。

输出描述:
如果存在满足条件的 x，输出一个实数表示该坐标（你只需要保证最终构造的三角形面积与 2 的绝对误差不超过 0.001 即可）；否则，输出 no answer。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。
注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。

示例1
输入
1 1
-1 1

输出
no answer

说明
在这个样例中，点 A 位于 (1,1)，点 B 位于 (−1,1)。
线段 AB 平行于 x 轴，长度为 2。
由于点 O 必须在 x 轴（y=0）上，三角形 ABO 以 AB 为底时，高恒等于 A 点（或 B 点）到 x 轴的距离，即 1。
此时三角形面积固定为 1/2 ×2×1=1。
由于 1≠2，因此不存在满足条件的点 O。


示例2
输入
5 5
-9 -7

输出
-0.5
*
#include<iostream>
#include<iomanip>
#include<cmath>
using namespace std;
int main()
{
    long long a, b, c, d;
    double h;
    cin >> a >> b >> c >> d;
    if (b == d)
    {
        h = 0.5 * abs(b - a) * abs(c);
        cout << (abs(h - 2) <= 1e-3 ? 0 : "no answer") << endl;
    }
    else
    {
        h = (4.0 - (1.0 * a * d - 1.0 * b * c)) / (c - d);
        cout << h << endl;
    }

    return 0;
}
*/

/* I
BenzenE

题目描述
小苯拿到了两个长度为 n 的数组 a1 ,a2 ,…,an 和 b1 ,b2 ,…,bn 。
小红想让小苯基于这两个数组生成一个新数组 c1 ,c2 ,…,cn ，需要满足：
∙对于1≦i≦n，ci=ai 或者 c1⊕c2⊕⋯⊕cn=0。
你能帮帮小苯吗？

【名词解释】
⊕：指位运算中的按位异或（Bitwise XOR），对两个整数的二进制表示按位进行异或运算。如果您需要更多位运算相关的知识，可以参考 OI-Wiki的相关章节。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦100) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数 n(1≦n≦10^5 )，表示数组长度。
第二行输入 n 个整数 a1 ,a2 ,…,an (0≦ai <2^30 )。
第三行输入 n 个整数 b1 ,b2 ,…,bn (0≦bi <2^30 )。

除此之外，保证单个测试文件的 n 之和不超过 2×10^5 。

输出描述:
对于每一组测试数据，新起一行。如果不存在满足条件的数组，直接输出 −1；否则，直接输出 n 个整数，表示你所构造的数组。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。
注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。

示例1
输入
2
3
1 3 6
5 8 2
2
1 2
3 4

输出
1 3 2
-1


说明
对于第一组测试数据：
∙ 选择 c1 = a1 = 1、c2 = a2 = 3、c3 = b3 = 2；
∙ 异或和为 1⊕3⊕2=0。
满足条件。当然，其他满足条件的解（如 5,3,6）也会被接受。

对于第二组测试数据，可能的异或和共有四种情况：
∙ 1⊕2=3；
∙ 1⊕4=5；
∙ 3⊕2=1；
∙ 3⊕4=7；
没有任何一种组合的结果为 0，故输出 −1。
*/

/* J √
Branch of Faith

题目描述
小红有一棵包含 n 个节点的完全二叉树[1] ，其中 1 号节点为根，i 号节点的左儿子编号是 2×i，右儿子编号是 2×i+1。
现在有 q 次询问，每次查询一个 x，你需要回答与 x 号节点深度[3] 相同的节点有多少个（包含 x 本身）。

【名词解释】
完全二叉树[1]：满足以下全部条件的二叉树[2] 。
∙若树的层数为 h，则除第 h 层外，其他各层（ 1 至 h−1 层）的节点数均达到最大值（即第 i(1≦i<h) 层节点数为 2^i−1 ）；
∙第 h 层的所有节点都连续集中在左侧，即节点之间不存在任何空位。
二叉树[2]：满足以下全部条件的树。
∙二叉树可以是空集；若不为空，则由一个根节点以及两棵互不相交的、分别称为左子树和右子树的二叉树组成；
∙每个节点要么没有父节点连接（此时该节点被称为根节点）、要么被 1 个父节点连接（此时该节点被称为父节点的子节点）；
∙每个节点连接的子节点数量要么为 0 （此时该节点被称为叶子节点），要么不超过 2，且此时每个子节点都有明确的“左”或“右”属性。
深度[3] ：从根节点到节点 u 的唯一路径上的边数，称为节点 u 的深度。根节点的深度为 0。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^4 ) 代表数据组数，每组测试数据描述如下：

第一行输入两个整数 n,q(1≦n≦10^18 ;1≦q≦2×10^5 )，表示二叉树的节点数、询问次数。
此后 q 行，第 i 行输入一个整数 xi (1≦xi ≦n)，表示第 i 次询问的节点编号。

除此之外，保证单个测试文件的 q 之和不超过2×10^5 。

输出描述:
对于每一次询问，新起一行输出一个整数，代表与 xi 号节点深度相同的节点数量。

示例1
输入
2
6 6
1
2
3
4
5
6
1145 3
1000
4
66

输出
1
2
2
3
3
3
512
4
64
*/
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    long long t, n, m, x, te, d, f, l;
    double h;
    cin >> t;
    while (t--)
    {
        cin >> n >> m;
        while (m--)
        {
            cin >> x;
            d = 0, te = x;
            while (te > 1)
            {
                te >>= 1;
                d++;
            }
            f = 1LL << d;
            l = (1LL << (d + 1)) - 1;
            cout << min(l, n) - f + 1 << endl;
        }

    }

    return 0;
}
