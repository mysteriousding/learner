/*
断舍离的智慧

问题描述
诺伊最近开始对断舍离的理念产生了兴趣，他决定尝试将这种理念应用到他的日常生活中。
他有一个独特的方式来实践断舍离：
他会连续  天，每天都会选择一个物品进行处理。
处理的方式可能是收纳、丢弃、或者赠送，不同的处理方式会带给诺伊不同程度的快乐，我们用整数 Ai 来表示第 i 天处理物品所带来的快乐值。
注意，当 Ai<0 时，表示诺伊在这一天的处理过程中遇到了困扰，他的快乐值下降了。

诺伊现在想知道，如果他在这 N 天中选择休息一天不做任何处理，他的总快乐值会达到怎样的程度。
请你帮他找出一个最佳的休息日，使得他的总快乐值最大。

输入格式
首先，您会读到一个整数 T，表示测试用例的数量。

每个测试用例的第一行包含一个整数 N，表示诺伊连续处理物品的天数。

接下来的一行包含 N 个整数 Ai，表示诺伊在第 i 天的快乐值。

数据范围保证：

1≤T≤1000。
1≤N≤10^5 。
−100≤Ai ≤100。
所有测试用例中的 N 之和不会超过 10^6 。
输出格式
对于每个测试用例，输出一行，表示诺伊的最大可能的总快乐值。

样例输入
4
3
1 -2 3
4
4 1 5 1
4
10 -10 -10 10
5
-5 -4 -3 -2 -1

样例输出
4
10
10
-10

说明
测试用例 1：诺伊可以选择在第 2 天休息，这样他的总快乐值为 1+3=4。

测试用例 2：诺伊可以选择在第 4 天休息，这样他的总快乐值为 4+1+5=10。

测试用例 3：诺伊可以选择在第 3 天休息，这样他的总快乐值为 10+(−10)+10=10。

测试用例 4：诺伊可以选择在第 1 天休息，这样他的总快乐值为 (−4)+(−3)+(−2)+(−1)=−10。
*/
#include <iostream>
#include <vector>
using namespace std;
int main()
{
    int t, n, m, h, s;
    vector<int>a;
    cin >> t;
    while (t--)
    {
        h = 2e9, s = 0;
        cin >> n;
        a.resize(n);
        for (int i = 0; i < n; i++)
        {
            cin >> m;
            s += m;
            if (h > m)h = m;
        }
        cout << s - h << endl;
    }

    return 0;
}
