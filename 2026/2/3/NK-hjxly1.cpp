//链接：https://ac.nowcoder.com/acm/contest/120561
//来源：牛客网
/*
A+B Problem


题目描述
如果您想查看本场比赛的  PDF 格式题面可以：点我下载
小苯正在学习 A+B Problem，为此他从家中翻出了恰好八个"七段码数位显示器"（以下简称显示器）。

如下图所示，显示器共有 7 个灯管，图中已标明编号。
点亮其中的一些灯管就可以形成合法的数字,0−9 的对应的点亮结果如下图二，其中红色灯管是被点亮的，灰色则是未被点亮（其余的结果均是不合法的数字）。


图1: 灯管编号    
https://uploadfiles.nowcoder.com/images/20250827/0_1756261501268/B17C85A6D5124E373A158ED18026B18C
图2: 数字 0∼9 对应的状态
https://uploadfiles.nowcoder.com/images/20250827/0_1756261511722/F267B5CEC10F8AA97EE81D8432729E87

遗憾的是，放置时间太久导致所有的显示器都发生了相同的故障，具体来说，在点亮他们的编号为 i 的灯管时，灯管都是仅有 pi% 的概率会被点亮，而还会有 100%−pi% 的概率不会被点亮（各根灯管的点亮尝试相互独立；不同显示器之间、同一显示器内不同编号灯管之间的点亮结果均互不影响）。

但小苯的学习还得进行下去，现在他会让小红指定一个整数 C(0≦C≦2026)，接着小苯会将其中的四个排成一排，另外四个排成另一排，并对其 7 根灯管（共 7×8=56 根）均各尝试一次点亮操作。
（由于所有显示器参数相同，具体选哪 4 台放在第一排与第二排均等价，可视为任意固定分配）。

现在请你计算出如下事件的概率（需全部满足）：
∙最终所有显示器均有灯管被点亮（也就是说显示器的灯管不能全灭）。
∙最终所有显示器显示的结果均为合法数字。
∙第一排的显示器前后拼接形成的四位十进制数记作 A，第二排的显示器前后拼接形成的四位十进制数记作 B 的话，满足：A+B=C。
（两排显示器从左到右依次作为千位、百位、十位、个位进行拼接，可以存在前导 0）。

如果您不了解分数取模，可以查看下方的备注。



输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数 T(1≦T≦10^3 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数 C(0≦C≦2026)，表示小红指定的整数。
第二行输入七个整数 p1 ,p2 ,…,p7 (0≦pi ≦100)，分别表示显示器中，每一根灯管在尝试点亮时，被点亮的概率百分比（概率为 pi%）。
输出描述:
对于每一组测试数据，新起一行输出一个整数，表示最终的概率（对 998244353 取模，注意： 998244353 是一个质数）。
可以证明答案可以表示为一个不可约分数 p/q ，为了避免精度问题，请直接输出整数 (p×q^−1 mod M) 作为答案，其中 M=(998244353)，q^−1 是满足 q×q^−1 ≡1(mod M) 的整数。

注意，如果您不了解分数取模，可以查看下方的备注。
示例1
输入
3
0
100 100 100 0 100 100 100
0
100 100 100 0 50 100 100
34
24 54 10 12 33 1 99
输出

1
994344961
20591129


说明
对于第一组测试数据，所有的显示器都恰好只能显示出 0，因此显示出 A 的四个显示器显示 0 的概率为 1，显示出 B 的也为 1，因此 A+B=0 一定成立，即概率为 1。
对于第二组测试数据，所有的显示器都恰好有 50% 的概率显示出 0，而另 50% 的概率显示非数字的不合法结果，因此四个显示 A 的显示器显示出 0 的概率为： (1/2)^4 ，显示 B 的也同理。
因此 A+B=0 的概率为 (1/2^4)^2 = 1/256 ，对 998244353 取模的值为 994344961。


备注:
分数取模的提示（教程）：
以下文中的 mod 表示取模，也就是大家平时写的 % 符号。

我们以任意分数：𝑎/𝑏 举例。
直接给出结论：根据费马小定理，在模数 m 为质数，且 b 不是 m 的倍数的情况下有：
𝑎/𝑏 mod m = a×(b^(m−2)) mod m。

也就是说在 mod m 的意义下，
1/b = b^(m−2) mod m。
例如：在 mod 998244353 的情况下，
2/3 =2×3^998244351 (mod 998244353)，这是因为 998244353 是一个质数，且 3 不是 998244353 的倍数。

上式中，b^(m−2) mod m 实际上就是我们常说的 "乘法逆元"，即把 " a 除以 b" 转化为 " a 乘上 b 的逆元"，这样一来结果算下来是正确的，同时我们将分数（也就是小数）域下的运算转为了整数域下的运算，这样一来就避免了小数可能产生的精度问题，同时不影响答案的正确性。
证明需要大量计算，这里不再展开，我们只需要使用结论即可。
*/
#include<iostream>
using namespace std;
long long N = 998244353;
long long mod_(long long a, long long b)
{
    long long res = 1;
    a %= N;
    while (b > 0)
    {
        if (b % 2)
            res = (res * a) % N;
        b /= 2;
        a = (a * a) % N;
    }
    return res;
}
long long mod_A(long long a, long long b)
{
    long long res = 0;
    a %= N;
    while (b > 0)
    {
        if (b & 1)
            res = (res + a) % N;
        a = (a << 1) % N;
        b >>= 1;
    }
    return res;
}
int main()
{
    int t, n, a[8], h = 14507691;
    long long b[10];
    bool v[10][8] = {
        {0,1,1,1,0,1,1,1},
        {0,0,0,1,0,0,1,0},
        {0,1,0,1,1,1,0,1},
        {0,1,0,1,1,0,1,1},
        {0,0,1,1,1,0,1,0},
        {0,1,1,0,1,0,1,1},
        {0,1,1,0,1,1,1,1},
        {0,1,0,1,0,0,1,0},
        {0,1,1,1,1,1,1,1},
        {0,1,1,1,1,1,1,0}
    };
    cin >> t;
    while (t--)
    {
        cin >> n;
        for (int i = 1; i <= 7; i++)
            cin >> a[i];
        for (int i = 0; i < 10; i++)
        {
            b[i] = 1;
            for (int j = 1; j <= 7; j++)
                b[i] = mod_A(b[i], v[i][j] ? a[i] : 100 - a[i]);
            b[i] = mod_A(b[i], h);
            cout << i << "  " << b[i] << endl;
        }
        cout << endl;
    }

    return 0;
}



