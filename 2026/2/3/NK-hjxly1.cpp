//链接：https://ac.nowcoder.com/acm/contest/120561
//来源：牛客网
/* A
A+B Problem

题目描述
如果您想查看本场比赛的  PDF 格式题面可以：点我下载
小苯正在学习 A+B Problem，为此他从家中翻出了恰好八个"七段码数位显示器"（以下简称显示器）。

如下图所示，显示器共有 7 个灯管，图中已标明编号。
点亮其中的一些灯管就可以形成合法的数字,0−9 的对应的点亮结果如下图二，其中红色灯管是被点亮的，灰色则是未被点亮（其余的结果均是不合法的数字）。


图1: 灯管编号    
https://uploadfiles.nowcoder.com/images/20250827/0_1756261501268/B17C85A6D5124E373A158ED18026B18C
图2: 数字 0∼9 对应的状态
https://uploadfiles.nowcoder.com/images/20250827/0_1756261511722/F267B5CEC10F8AA97EE81D8432729E87

遗憾的是，放置时间太久导致所有的显示器都发生了相同的故障，具体来说，在点亮他们的编号为 i 的灯管时，灯管都是仅有 pi% 的概率会被点亮，而还会有 100%−pi% 的概率不会被点亮（各根灯管的点亮尝试相互独立；不同显示器之间、同一显示器内不同编号灯管之间的点亮结果均互不影响）。

但小苯的学习还得进行下去，现在他会让小红指定一个整数 C(0≦C≦2026)，接着小苯会将其中的四个排成一排，另外四个排成另一排，并对其 7 根灯管（共 7×8=56 根）均各尝试一次点亮操作。
（由于所有显示器参数相同，具体选哪 4 台放在第一排与第二排均等价，可视为任意固定分配）。

现在请你计算出如下事件的概率（需全部满足）：
∙最终所有显示器均有灯管被点亮（也就是说显示器的灯管不能全灭）。
∙最终所有显示器显示的结果均为合法数字。
∙第一排的显示器前后拼接形成的四位十进制数记作 A，第二排的显示器前后拼接形成的四位十进制数记作 B 的话，满足：A+B=C。
（两排显示器从左到右依次作为千位、百位、十位、个位进行拼接，可以存在前导 0）。

如果您不了解分数取模，可以查看下方的备注。



输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数 T(1≦T≦10^3 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数 C(0≦C≦2026)，表示小红指定的整数。
第二行输入七个整数 p1 ,p2 ,…,p7 (0≦pi ≦100)，分别表示显示器中，每一根灯管在尝试点亮时，被点亮的概率百分比（概率为 pi%）。
输出描述:
对于每一组测试数据，新起一行输出一个整数，表示最终的概率（对 998244353 取模，注意： 998244353 是一个质数）。
可以证明答案可以表示为一个不可约分数 p/q ，为了避免精度问题，请直接输出整数 (p×q^−1 mod M) 作为答案，其中 M=(998244353)，q^−1 是满足 q×q^−1 ≡1(mod M) 的整数。

注意，如果您不了解分数取模，可以查看下方的备注。

示例1
输入
3
0
100 100 100 0 100 100 100
0
100 100 100 0 50 100 100
34
24 54 10 12 33 1 99

输出
1
994344961
20591129


说明
对于第一组测试数据，所有的显示器都恰好只能显示出 0，因此显示出 A 的四个显示器显示 0 的概率为 1，显示出 B 的也为 1，因此 A+B=0 一定成立，即概率为 1。
对于第二组测试数据，所有的显示器都恰好有 50% 的概率显示出 0，而另 50% 的概率显示非数字的不合法结果，因此四个显示 A 的显示器显示出 0 的概率为： (1/2)^4 ，显示 B 的也同理。
因此 A+B=0 的概率为 (1/2^4)^2 = 1/256 ，对 998244353 取模的值为 994344961。


备注:
分数取模的提示（教程）：
以下文中的 mod 表示取模，也就是大家平时写的 % 符号。

我们以任意分数：𝑎/𝑏 举例。
直接给出结论：根据费马小定理，在模数 m 为质数，且 b 不是 m 的倍数的情况下有：
𝑎/𝑏 mod m = a×(b^(m−2)) mod m。

也就是说在 mod m 的意义下，
1/b = b^(m−2) mod m。
例如：在 mod 998244353 的情况下，
2/3 =2×3^998244351 (mod 998244353)，这是因为 998244353 是一个质数，且 3 不是 998244353 的倍数。

上式中，b^(m−2) mod m 实际上就是我们常说的 "乘法逆元"，即把 " a 除以 b" 转化为 " a 乘上 b 的逆元"，这样一来结果算下来是正确的，同时我们将分数（也就是小数）域下的运算转为了整数域下的运算，这样一来就避免了小数可能产生的精度问题，同时不影响答案的正确性。
证明需要大量计算，这里不再展开，我们只需要使用结论即可。
*
#include<iostream>
using namespace std;
long long N = 998244353;
long long mod_(long long a, long long b)
{
    long long res = 1;
    a %= N;
    while (b > 0)
    {
        if (b % 2)
            res = (res * a) % N;
        b /= 2;
        a = (a * a) % N;
    }
    return res;
}
long long mod_A(long long a, long long b)
{
    long long res = 0;
    a %= N;
    while (b > 0)
    {
        if (b & 1)
            res = (res + a) % N;
        a = (a << 1) % N;
        b >>= 1;
    }
    return res;
}
int main()
{
    int t, n, a[8], h = 14507691;
    long long b[10];
    bool v[10][8] = {
        {0,1,1,1,0,1,1,1},
        {0,0,0,1,0,0,1,0},
        {0,1,0,1,1,1,0,1},
        {0,1,0,1,1,0,1,1},
        {0,0,1,1,1,0,1,0},
        {0,1,1,0,1,0,1,1},
        {0,1,1,0,1,1,1,1},
        {0,1,0,1,0,0,1,0},
        {0,1,1,1,1,1,1,1},
        {0,1,1,1,1,1,1,0}
    };
    cin >> t;
    while (t--)
    {
        cin >> n;
        for (int i = 1; i <= 7; i++)
            cin >> a[i];
        for (int i = 0; i < 10; i++)
        {
            b[i] = 1;
            for (int j = 1; j <= 7; j++)
                b[i] = mod_A(b[i], v[i][j] ? a[i] : 100 - a[i]);
            b[i] = mod_A(b[i], h);
            cout << i << "  " << b[i] << endl;
        }
        cout << endl;
    }

    return 0;
}
*/

/* B
Card Game

题目描述
小苯正在和小红玩卡牌游戏。
游戏中有 2×n 张牌，每张牌上都有一个数字，所有牌的数字恰好构成了一个长度为 2×n 的排列。
游戏最初时，2×n 张卡牌被恰好平均分成了两组 n 张牌，并分别发给了两人，小苯第 i 张牌上的数字是 ai ，而小红第 i 张牌上的数字是 bi ，具体的游戏过程如下：
∙如果两人之中有一人已经没有牌了，则游戏结束。
∙比较两人当前手牌中的最前一张，对应数字大的那一方得一分并将该张牌从自己手牌移除；另一方不得分，手牌也不变。随后进入下一轮。

而现在小苯希望自己的得分尽可能多，为此他在游戏开始前可以任意地重新排列自己的牌，以得到更高的游戏分数。
现在你的任务则是求出，有多少种重新排列（选择不进行重排也是一种方案）的方式，能使得小苯得到他能得到的最高分。
由于答案可能很大，请将答案对 998244353 取模后输出。

【名词解释】
长度为 n 的排列：由 1,2,…,n 这 n 个整数、按任意顺序组成的数组（每个整数均恰好出现一次）。
例如，{2,3,1,5,4} 是一个长度为 5 的排列，而 {1,2,2} 和 {1,3,4} 都不是排列，因为前者存在重复元素，后者包含了超出范围的数。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^5 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个正整数 n(1≦n≦2×10^5 )，表示两人的卡牌数量。
第二行输入 n 个正整数 a1 ,a2 ,…,an (1≦ai ≦2×n)，表示小苯的卡牌上的数字。
第三行输入 n 个正整数 b1 ,b2 ,…,bn (1≦bi ≦2×n)，表示小红的卡牌上的数字。
（保证 a 数组和 b 数组共同构成一个长度为 2×n 的排列。）

除此之外，保证单个测试文件的 n 之和不超过 2×10^5 。


输出描述:
对于每一组测试数据，新起一行输出一个整数，表示小苯重新排列自己卡牌，使得他能得到的最高分的方案数对 998244353 取模后的值。

示例1
输入
3
2
1 2
3 4
4
1 8 7 2
3 6 4 5
5
9 8 2 3 1
10 7 5 6 4

输出
2
4
12


说明
对于第一组测试数据，无论小苯如何重排他的卡牌，他的最高得分总是 0，而 {1,2} 和 {2,1} 两种重排方式都能使得他得到最高分，因此输出 2。
*/

/* C √
Array Covering

题目描述
给定长度为 n 的数组 a1 ,a2 ,…,an ，其中第 i 个数的值为 ai 。

小苯希望数组中所有数字的总和尽可能大，为此他可以做任意次如下操作：
∙选择一对下标 l,r(1≦l<r≤n)，接着将 (l,r) 区间（注意是开区间）内的所有数都变为区间端点值的较大者。
形式化地，对所有 j(l<j<r)，均执行：aj :=max( al ,ar )（其中 := 表示赋值操作）。

你的任务就是求出数组总和的最大值。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^5 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个正整数 n(1≦n≦5×10^5 )，表示数组 a 的长度。
第二行输入  个正整数 a1 ,a2 ,…,an (1≦ai ≦10^9 )，表示最初时所有数字的值。

除此之外，保证单个测试文件的 n 之和不超过 5×10^5 。

输出描述:
对于每一组测试数据，新起一行输出一个正整数，表示在可以进行任意次操作的情况下，所有数字之和的最大值。

示例1
输入
2
3
5 1 5
4
1 1 1 1

输出
15
4


说明
对于第一组测试数据，可以选择 l=1,r=3 操作一次，操作完后数组为 {5,5,5}，求和为 15。
我们可以证明，无法通过其他操作使得总和更大。
*
#include<iostream>
using namespace std;
int main()
{
    long long t, n, k, m, h;
    cin >> t;
    while (t--)
    {
        h = 0;
        cin >> n;
        for (int i = 0; i < n; i++)
        {
            cin >> k;
            if (!i)m = k;
            if (h < k)h = k;
        }
        cout << m + k + h * (n - 2) << endl;
    }

    return 0;
}
*/

/* D
Sequence Coloring

题目描述
给定一个长度为 n 的数字序列 a1 ,a2 ,…,an ，每一个元素都有一个颜色，且初始时要么为白色，要么为黑色，使用其值的大小表示其颜色：
若 ai >0，则第 i 个元素为白色；否则为黑色。

小苯可以在第 0 秒时选择其中至多 k 个白色元素染红，随后，从第 1 秒开始，每秒都会发生如下事件：
∙对于第 i 个元素 ai ，如果它是红色的，那么将其右侧 ai 个元素中的白色元素也染红。
形式化地，对于所有红色元素所在的位置 i(1≦i≦n)，将第 i+1 到第 min(n,i+ai ) 个元素中的白色元素也染红；
∙所有的红色元素同步进行这一操作（即每一秒开始时已经是红色的元素，会在该秒内尝试染红其它元素）；
∙黑色元素并不会、也无需被染红。

请你帮助小苯以最优策略染色最初的数字，使得所有的白色元素都被染红的时间尽可能短（可以为 0 秒）。
求出这个最短时间，或报告无论如何都无法将所有的白色元素都染红。

输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数 T(1≦T≦10^5 ) 代表数据组数，每组测试数据描述如下：

第一行两个整数 n,k(1≦k≦n≦5×10^5 )，表示数字序列的长度、最开始可以染红的元素个数。
第二行 n 个整数 a1 ,a2 ,…,an (0≦ai≦n)，表示序列中的元素。
其中 ai >0 表示白色，ai =0 表示黑色。

除此之外，保证单个测试文件的 n 之和不超过 5×10^5 。

输出描述:
对于每一组测试数据，新起一行。
如果可以将所有的白色元素都染红，输出一个整数表示最短的全染红时间；否则输出 −1。

示例1
输入
3
6 2
2 0 1 1 0 1
5 1
1 1 1 1 1
5 1
1 0 1 0 1

输出
2
4
-1


说明
对于第一组测试数据，我们一开始选择染红：i=1 和 i=6 这两个位置的元素即可，即 {2,0,1,1,0,1}，随后：
∙第一秒后，序列变为 {2,0,1,1,0,1}；
∙第二秒后，序列变为 {2,0,1,1,0,1}。
此时，序列中所有的白色元素均已被染红，耗时 2 秒，可以证明不存在更优的方案，因此输出 2。
*/

/* E √
Block Game

题目描述
小苯正在玩方块小游戏，游戏中有一排 n 个方块，每个方块上都有一个数字，此外，他还有一个写着数字 k 的万能方块，游戏过程如下。

小苯可以进行任意次（可以为 0 次）以下操作：
∙将万能方块从方块序列的最左侧插入，同时最右侧的第 n 个方块会被挤出这一行，成为新的万能方块。
形式化地，记开始时的序列为 a1′ ,a2′ ,…,an′（初始时 ai′ = ai ），万能方块值为（初始时 k′= k），操作完成后序列变为 k′,a1′,…,a(n−1)′，万能方块上的数字变为 an′，其他方块保持相对顺序整体右移一位。

你的任务是计算出，按照最优方式经过若干次操作后，从左往右数第一个方块上的数字加上最终的万能方块上的数字的总和的最大值。

输入描述:
每个测试文件包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^5 ) 代表数据组数，每组测试数据描述如下：

第一行输入两个整数 n,k(1≦n≦2×10^5; −10^6 ≦k≦ 10^6 )，表示方块个数、初始的万能方块上的数字。
第二行输入 n 个整数 a1 ,a2 ,…,an (−10^6 ≦ai≦ 10^6 )，表示从左往右数第 i 个方块上写的数字。

除此之外，保证单个测试文件的 n 之和不超过 2×10^5 。

输出描述:
对于每一组测试数据，新起一行输出一个整数，表示最终：
从左往右数第一个方块上的数字 + 万能方块上的数字之和的最大值。

示例1
输入
2
6 5
1 2 3 3 2 1
5 3
1 1 1 1 1

输出
6
4

说明
对于第一组测试数据，我们操作一次后，方块序列变为 {5,1,2,3,3,2}，此时万能方块变为 an′ =1，总和为 6 达到最大。
 可以证明不存在更优的答案。
*
#include<iostream>
using namespace std;
int main()
{
    long long t, n, k, m, h, x;
    cin >> t;
    while (t--)
    {
        x = -1e9;
        cin >> n >> k;
        h = k;
        for (int i = 0; i < n; i++)
        {
            cin >> m;
            m += h;
            h = m - h;
            if (x < m)x = m;
        }
        if (x < h + k)x = h + k;
        cout << x << endl;
    }

    return 0;
}
*/

/* F
Permutation Counting

题目描述
这天小红给了小苯一个长度为 n 的排列 p，但她把 p 隐藏了起来，只告诉了小苯 m 条有关 p 的信息，具体的：
∙第 i(1≦i≦m) 条信息包含 3 个参数 li ,ri ,ki ，表示 p 在区间 [li ,ri] 中的最大值等于 ki 。
形式化地，(pli ,pl(i+1) ,…,pri )=ki 。
你的任务则是帮助小苯确定，有多少种可能的排列 p 都符合上述的所有信息。
由于答案可能很大，请将答案对 998244353 取模后输出。
当然也有可能不存在这样的排列，此时输出 0。

【名词解释】
长度为 n 的排列：由 1,2,…,n 这 n 个整数、按任意顺序组成的数组（每个整数均恰好出现一次）。
例如，{2,3,1,5,4} 是一个长度为 5 的排列，而 {1,2,2} 和 {1,3,4} 都不是排列，因为前者存在重复元素，后者包含了超出范围的数。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^5 ) 代表数据组数，每组测试数据描述如下：

第一行输入两个正整数 n,m(1≦n,m≦2×10^6 )，表示排列 p 的长度、信息条数。
此后 m 行，第 i 行输入三个正整数 li ,ri ,ki (1≦li≦ri≦n;1≦ki≦n)，描述第 i 条信息。
除此之外，保证单个测试文件的 n 之和、m 之和均不超过 2×10^6 。

输出描述:
对于每一组测试数据，新起一行输出一个整数，表示可能的排列个数对 998244353 取模后的答案。

示例1
输入
4
3 1
1 2 2
5 2
2 3 4
2 5 5
5 1
2 3 4
5 1
1 5 4

输出
2
24
36
0

说明
对于第一组测试数据，长度为 3 的排列中，满足在区间 [1,2] 中的最大值等于 2 的排列有：{1,2,3}、{2,1,3} 两个。
对于第四组测试数据，长度为 5 的排列，在区间 [1,5] 中的最大值一定是 5；而信息中说是 4 显然不可能，因此不存在这样的排列。
*
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
long long N = 998244353;
struct bb
{
    int l, r, k;
};
bool pd(bb& a, bb& b)
{
    return a.k < b.k;
}
long long mod_A(long long a, long long b)
{
    long long res = 0;
    a %= N;
    while (b > 0)
    {
        if (b & 1)
            res = (res + a) % N;
        a = (a << 1) % N;
        b >>= 1;
    }
    return res;
}
int main()
{
    int t, n, m;
    bool v, u;
    vector<int>a, b;
    vector<bb>e;
    cin >> t;
    while (t--)
    {
        u = 0;
        cin >> n >> m;
        a.resize(n + 1, n);
        b.resize(n + 1, 0);
        e.resize(m);
        for (int i = 0; i < m; i++)
            cin >> e[i].l >> e[i].r >> e[i].k;
        sort(e.begin(), e.end(), pd);
        for (int i = 0; i < m; i++)
        {
            v = 1;
            for (int j = e[i].l; j <= e[i].r; j++)
            {
                if (v && a[j] > e[i].k)v = 0;
                a[j] = e[i].k;
            }
            if (v)
            {
                cout << 0 << endl;
                u = 1;
                break;
            }
        }
        if (u)continue;
        for (int i = 1; i <= n; i++)
            b[a[i]]++;
        for (int i = n; i > 0; i--)
        {
            if (b[i] <= 0)
            {
                cout << 0 << endl;
                u = 1;
                break;
            }
            b[i - 1] += b[i] - 1;
        }
        if (u)continue;
        cout << 1 << endl;

    }

    return 0;
}
*/

/* G √
Digital Folding

题目描述
小苯发现了一种特殊的数字运算，称为"数字折叠"。
对于一个正整数 x，定义其 "折叠数" 为：
∙将 x 的十进制数位翻转并去除前导 0，x 的值更改为翻转后得到的新数。
例如，123 操作后会变为 321，而 120 会变为 。
现在小苯拿到了一个区间 [l,r]，他想知道如果将区间中所有的整数 (l≦i≦r) 的折叠数都求出，那么其中的最大值是多少。
你的任务就是求出这个最大值。

输入描述:
每个测试文件包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^4 ) 代表数据组数，每组测试数据描述如下：

在一行上输入两个整数 l,r(1≦l≦r≦10^15 )，表示询问的区间。

输出描述:
对于每一组测试数据，新起一行输出一个整数，表示区间中所有数的 "折叠数" 的最大值。

示例1
输入
3
1 20
1000 10000
1 999

输出
91
9999
999

说明
对于第一组测试数据，折叠数最大的数字是 19，其折叠数是 91。
*
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
int main()
{
    long long t, n, m, x, h, ma, k;
    cin >> t;
    while (t--)
    {
        cin >> n >> m;
        h = m, x = 0;
        while (h)
        {
            x = x * 10 + h % 10;
            h /= 10;
        }
        ma = x;
        k = 1;
        for (long long i = m - 1; i >= n; i -= k)
            if (i % (k * 10) / k == 9)
            {
                h = i, x = 0;
                while (h)
                {
                    x = x * 10 + h % 10;
                    h /= 10;
                }
                if (ma < x)ma = x;
                k *= 10;
            }
        cout << ma << endl;
    }

    return 0;
}
*/

/* H
Blackboard

题目描述
小红在黑板上写了一个计算式，具体来讲是 n 个数字 a1 ,a2 ,…,an ，其中间由 n−1 个加号（‘+’）连接组成：a1+a2+⋯+an 。
现在小苯想去擦去黑板上的一些 ‘+’ 运算符，但他擦得很不干净，只擦去了加号中的横线（‘-’），剩下的部分就是一个竖线（‘|’）了。
巧合的是，∣ 恰好也是一个运算符：按位或 or。
小苯想知道，有多少种不同的擦黑板方式，能使得按照新算式进行计算，结果和擦黑板前的算式计算结果相同，请你帮他算一算。
注意，不擦黑板也是一种方案。
由于答案可能很大，请将答案对 998244353 取模后输出。

【注】
特别的，在本题中我们认为 or 运算符的优先级大于加法运算 ‘+’。
两种擦黑板方式不同当且仅当存在至少一个运算符位置，其在其中一个方式中为 ‘+’，而在另一个方式中为 ‘|’（即按位或 or）。

【名词解释】
or：指位运算中的按位或（Bitwise OR），对两个整数的二进制表示按位进行或运算。如果您需要更多位运算相关的知识，可以参考 OI-Wiki的相关章节。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦100) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数 n(1≦n≦2×10^5 )，表示黑板上的数字个数。
第二行输入 n 个整数 a1 ,a2​ ,…,an (0≦ai <2^31 )，表示黑板上的数字。
除此之外，保证单个测试文件的 n 之和不超过 2×10^5 。

输出描述:
对于每一组测试数据，新起一行输出一个整数，表示不同的擦黑板方案个数对 998244353 取模后的答案。

示例1
输入
3
2
1 2
3
1 2 3
4
1 2 0 4

输出
2
2
8

说明
对于第一组测试数据，对于 1+2 这个计算式：
∙我们可以选择擦中间的 ‘+’，就能得到： 1∣2=3，原式运算结果也为 3，因此是一种方案；
∙不擦黑板显然是一种方案。
综上，共有两种方案。
*
#include<iostream>
#include<vector>
using namespace std;
int main()
{
    int t, n, m, h, c;
    vector<int>a;
    cin >> t;
    while (t--)
    {
        cin >> n;
        m = 0;
        a.resize(n);
        for (int i = 0; i < n; i++)
            cin >> a[i], m += a[i];

    }

    return 0;
}
*/

/* I
AND vs MEX

题目描述
小苯有一个可重整数集合 S，初始为空。现在他可以进行任意次以下操作，给 S 中加入一些元素，具体的：
∙ 他可以从区间 [l,r] 中选择若干个（至少一个）不同的整数，将这些整数的 AND（按位与）加入集合 S。
他可以做任意次上述操作，请问 S 的 MEX 最大可以达到多少。

【名词解释】
AND：指位运算中的按位与（Bitwise AND），对两个整数的二进制表示按位进行与运算。如果您需要更多位运算相关的知识，可以参考 OI-Wiki的相关章节。
MEX：整数集合的 MEX 定义为没有出现在集合中的最小非负整数。
例如，MEX(1,2,3)=0、MEX(0,2,5)=1。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^5 ) 代表数据组数，每组测试数据描述如下：

在一行上输入两个整数 l,r(0≦l≦r<2^30 )，表示区间。

输出描述:
对于每一组测试数据，新起一行输出一个整数，表示最大的 MEX。

示例1
输入
3
3 4
1 2
0 10

输出
1
3
11

说明
对于第一组测试数据，我们只能选择 3 和 4 将他们的 AND（即 0）加入 S，此时 S 的 MEX=1。
*/

/* J
MST Problem

题目描述
小苯拿到了一个由 n 个点、n×(n−1)/2 条边组成的无向完全图，没有重边和自环，其中第 i 个点的点权为 ai 。u,v 两点之间的边权为 au + av 。

而调皮的小红删除掉了其中一些边，导致图不再是一个完全图，具体来讲有 m 条删除记录，第 j 条记录由一个点对 (uj ,vj ) 组成，表示小红删除了这条边。
注意，记录可能有重复，即可能存在两条记录删除的边是一样的。

现在你的任务就是求出这张图的最小生成树的权重（树中所有边的权重之和最小）。
如果此时图不存在最小生成树，则输出 −1。

【名词解释】
最小生成树：对于一张由 n 个节点构成的连通图，选出 n−1 条边将所有节点连通，且使得这 n−1 条边的权重之和最小，这样的结构称为最小生成树。

输入描述:
每个测试文件均包含多组测试数据。
第一行输入一个整数 T(1≦T≦10^5 ) 代表数据组数，每组测试数据描述如下：

第一行输入两个整数 n,m(2≦n≦3×10^5 ; 1≦m≦3×10^5 )，表示图的节点个数、小红删除边的记录条数。
第二行输入 n 个整数 a1 ,a2 ,…,an (1≦ai​ ≦10^9 )，表示每个节点的点权。
接下来 m 行，第 j 行输入两个正整数 uj ,vj (1≦uj ,vj ≦n;vuj != vj )，描述第 j 条删除记录。

除此之外，保证单个测试文件的 n 之和、m 之和均不超过 3×10^5 。

输出描述:
对于每一组测试数据，新起一行输出一个整数，如果此时图存在最小生成树，则输出整张图的最小生成树的权重；否则直接输出 −1。

示例1
输入
3
3 1
1 2 3
2 3
4 3
2 2 2 2
1 2
2 3
3 4
3 2
1 2 3
1 2
2 3

输出
7
12
-1

说明
对于第一组测试数据，整个图已经被删成一棵树，因此图自己就是自己的唯一生成树，当然也就是最小生成树，仅剩的两条边 (1,2) 和 (1,3) 的权分别为：
1+2=3,1+3=4，因此最小生成树权重为 7。
*/

/* K √
Constructive

题目描述
给定一个正整数 n，你需要构造一个长度为 n 的数组 a1 ,a2 ,…,an ，满足以下条件：
∙数组中的每个元素 ai 都是正整数；
∙所有元素的乘积等于所有元素的和；
∙数组中的元素互不相同。
小苯想知道，对于给定的 n，是否存在这样的数组。如果存在，请构造字典序最小的解；如果不存在报告无解。

【名词解释】
数组的字典序比较：从左到右逐个比较两个数组的元素。
如果在某个位置上元素不同，比较这两个元素的大小，元素小的数组字典序也小。
如果一直比较到其中一个数组结束，则长度较短的数组字典序更小。
例如，{2,3,4,5} 的字典序小于 {2,4,3,5}，也小于 {3,2,4,5}。

输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数 T(1≦T≦100) 代表数据组数，每组测试数据描述如下：

在一行上输入一个整数 n(1≦n≦100)，表示数组的长度。
除此之外，保证单个测试文件中所有 n 之和不超过 10^3 。

输出描述:
对于每组测试数据，如果不存在满足条件的数组，直接输出 NO，否则：
∙第一行输出 YES；
∙第二行输出 n 个正整数，表示字典序最小的满足条件的数组，元素间用单个空格分隔；

示例1
输入
2
1
2

输出
YES
1
NO

说明
对于第一组测试数据，数组 {1} 显然满足条件。
对于第二组测试数据，可以证明找不到满足条件的数组。
*
#include<iostream>
using namespace std;
int main()
{
    int t, n;
    cin >> t;
    while (t--)
    {
        cin >> n;
        cout << (n == 1 ? "YES\n1" : n == 3 ? "YES\n1 2 3" : "NO") << endl;
    }

    return 0;
}
*/

/* L √
Need Zero

题目描述
小苯拿到了一个正整数 n，现在他希望 n 的个位数是 0，为此他必须执行下述操作恰好一次：
∙选择一个正整数 x(1≦x≦10^5 )，并执行 n:=n×x（其中 := 表示赋值操作）。
你的任务就是帮助小苯找出最小的 x。
我们可以证明，一定存在合法的答案。

输入描述:
输入一个正整数 n(1≦n≦10^5 )，表示小苯拿到的数字。

输出描述:
输出一个正整数，表示最小的合法解 x（可以证明在题目的限定范围内一定有解）。

示例1
输入

125
输出
2

说明
在这个样例中，对于 n=125，我们只需要选择 x=2，就可以将 n 变为 125×2=250，满足其个位数为 0。
显然 2 是最小的正整数解。


示例2
输入
10

输出
1

说明
在这个样例中，对于 n=10，我们选择 x=1 即可，操作后 n 不变，满足条件。
显然 1 是最小的正整数解。
*/
#include<iostream>
using namespace std;
int main()
{
    int n, x[10] = { 1,10,5,10,5,2,5,10,5,10 };
    cin >> n;
    n %= 10;
    cout << x[n] << endl;

    return 0;
}
