//链接：https://ac.nowcoder.com/acm/contest/
//来源：牛客网
/* A
智乃的二进制

题目描述
智乃定义一个十进制正整数是“好”的，当且仅当其十进制表示中仅包含数字
0
0 和
1
1，且数字
1
1 的出现次数不超过
2
2。其十进制表示对应的字符串是其二进制表示对应的字符串的一个后缀。
例如：
101
101（10进制），其中只有
2
2 个数位为
1
1，转写成二进制为
1100101
1100101（2进制），其二进制包含后缀
101
101，就说它是“好”的。
前
9
9 个“好”数分别为：
1
1、
10
10、
11
11、
100
100、
101
101、
110
110、
1000
1000、
1001
1001、
1100
1100。

现在智乃想要知道，从小到大排列后的第
𝑘
k 个符合条件的“好”数是多少。由于答案可能很大，请将答案对
(
1
0
9
+
7
)
(10
9
 +7) 取模后输出。

【名词解释】
字符串的后缀：从字符串的最后一个字符开始，向前连续取若干个字符得到的字符串。更具体地，字符串
𝑠
s 后
𝑖
i 个字符构成的字符串被称为
𝑠
s 的第
𝑖
i 个后缀，也记为
𝑠
[
𝑛
−
𝑖
+
1..
𝑛
]
s[n−i+1..n]。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
𝑇
(
1
≤
𝑇
≤
1
0
4
)
T(1≤T≤10
4
 ) 代表数据组数，每组测试数据描述如下：

输入一个正整数
𝑘
(
1
≤
𝑘
≤
1
0
18
)
k(1≤k≤10
18
 )，表示要查询的第
𝑘
k 个“好”数。
输出描述:
对于每一组测试数据，新起一行输出一个整数，表示答案对
(
1
0
9
+
7
)
(10
9
 +7) 取模后的结果。
示例1
输入
复制
10
1
2
3
4
5
6
7
8
9
114514
输出
复制
1
10
11
100
101
110
1000
1001
1100
722497934
说明
注意第
9
9 个符合条件的数字不是
1010
1010，因为
1010
1010 的二进制表示为
1111110010
1111110010，不符合条件。
*
#include<iostream>
#include<cmath>
using namespace std;
const long long mod_ = 1e9 + 7;
inline long long pow10(long long n)
{
    long long res = 1, base = 10;
    while (n > 0)
    {
        if (n % 2)res = (res * base) % mod_;
        base = (base * base) % mod_;
        n /= 2;
    }
    return res;
}
int main()
{
    long long t, k, n, m;
    cin >> t;
    while (t--)
    {
        cin >> k;
        n = sqrt(k * 2) + 0.5;
        m = k - n * (n - 1) / 2 - 1;
        cout << (pow10(n - 1) + (long long)(pow10(m) / 10)) % mod_ << endl;
    }

    return 0;
}
*/

/* B √
智乃的瓷砖

题目描述
智乃想要在他家的浴室密铺一种菱形图案的瓷砖，具体来讲，她现在有两种不同图案的瓷砖，一种是 "/"（斜杠）形状，另一种是 "\"（反斜杠）形状的。
假设她家的墙面可以看做是一个
n
n 行
m
m 列的二维字符矩阵，现在规定其左上角的形状为 "/" 型，且每一对上下相邻、左右相邻的瓷砖均形状不同。

例如，下面这个字符矩阵就是一个
6
×
10
6×10 的图形：
/\/\/\/\/\
\/\/\/\/\/
/\/\/\/\/\
\/\/\/\/\/
/\/\/\/\/\
\/\/\/\/\/
请你告诉智乃这面墙在铺好瓷砖后的形状应该是怎样的。
输入描述:
在一行上输入两个正整数
n
,
m
(
1
≤
n
,
m
≤
100
)
n,m(1≤n,m≤100)，表示智乃家墙面的行数、列数。
输出描述:
请输出一个
n
n 行
m
m 列的字符矩阵，表示墙面的形状。
示例1
输入
复制
1 1
输出
复制
/
示例2
输入
复制
6 10
输出
复制
/\/\/\/\/\
\/\/\/\/\/
/\/\/\/\/\
\/\/\/\/\/
/\/\/\/\/\
\/\/\/\/\/
*
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int n, m;
    char a[2] = { '/','\\' };
    bool u;
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        u = i % 2;
        for (int j = 0; j < m; j++)
            cout << a[u], u = !u;
        cout << endl;
    }

    return 0;
}
*/

/* C
智乃的草坪

题目描述
智乃有一块矩形草坪，从地图正上方俯视，草坪的四个端点分别位于坐标
(
0
,
r
)
(0,r)、
(
0
,
−
r
)
(0,−r)、
(
c
,
r
)
(c,r)、
(
c
,
−
r
)
(c,−r)。
现在智乃有
n
n 个自动洒水装置，第
i
i 个洒水装置位于坐标
(
p
i
,
0
)
(p
i
​
 ,0) 上，浇水速率为
v
i
v
i
​
 ，保证洒水装置的坐标一定位于草坪内部或边缘。
当这些洒水装置启动，
t
t 个时间单位以后，第
i
i 个洒水装置洒水的范围是一个以坐标
(
p
i
,
0
)
(p
i
​
 ,0) 为圆心，以
v
i
×
t
v
i
​
 ×t 为半径的圆。
当经过
t
t 个时间单位以后，所有洒水装置洒水的范围覆盖了整个草坪的矩形，就说明智乃完成了她的浇水工作。更具体地，若矩形区域内的所有点
(
x
,
y
)
(x,y) 满足
0
≤
x
≤
c
0≤x≤c 且
−
r
≤
y
≤
r
−r≤y≤r 均被至少一个启动的圆覆盖，则称完成了浇水工作。

现在由于电力紧缺，智乃发现他至多只能启动其中的
k
k 个洒水装置。问智乃完成整个草坪洒水工作的最短时间是多少。显然，在经历足够长的时间后，即使只使用
1
1 个洒水器也能完成工作，所以答案一定存在。
输入描述:
第一行输入四个非负整数
n
,
k
,
r
,
c
(
1
≤
n
≤
1
0
5
;
 
1
≤
k
≤
n
;
 
1
≤
r
,
c
≤
1
0
6
)
n,k,r,c(1≤n≤10
5
 ;1≤k≤n;1≤r,c≤10
6
 )，分别表示总共的洒水装置数、最多启动的洒水装置数、草坪的一半高度和宽度。
此后
n
n 行，第
i
i 行输入两个整数
p
i
,
v
i
(
0
≤
p
i
≤
c
;
 
1
≤
v
i
≤
1
0
4
)
p
i
​
 ,v
i
​
 (0≤p
i
​
 ≤c;1≤v
i
​
 ≤10
4
 )，表示第
i
i 个洒水装置的坐标和洒水速率。
输出描述:
输出一个实数，表示最短工作时间。

由于实数的计算存在误差，当误差的量级不超过
1
0
−
4
10
−4
  时，您的答案都将被接受。具体来说，设您的答案为
a
a，标准答案为
b
b，当且仅当
∣
a
−
b
∣
max
⁡
(
1
,
∣
b
∣
)
≤
1
0
−
4
max(1,∣b∣)
∣a−b∣
​
 ≤10
−4
  时，您的答案将被接受。
示例1
输入
复制
2 1 10 1000000
0 114
1000000 514
输出
复制
1945.52529193
示例2
输入
复制
2 2 10 1000000
0 114
1000000 514
输出
复制
1592.35668843
示例3
输入
复制
2 2 200000 1000000
0 114
1000000 514
输出
复制
1853.90929144
说明
在这个样例中，如图所示，深绿色重合部分为草坪范围。
https://uploadfiles.nowcoder.com/images/20260211/0_1770800665419/48920B1D18A5C84BD50995ABE187C794

备注:
可以使用几何画板辅助完成本题：https://www.desmos.com/calculator?lang=zh-CN。
*/

/* D
智乃的果子

题目描述
智乃有
n
n 种不同的果子，第
i
i 种果子有
c
i
c
i
​
  个，重量为
w
i
w
i
​
 。初始时共有
∑
i
=
1
n
c
i
∑
i=1
n
​
 c
i
​
  堆，每堆只包含
1
1 个果子，其重量等于该果子的重量。

智乃可以使用一个操作将任意两堆果子合并成一堆，合并的代价与合并后新堆的重量均为两堆的重量之和。
显然，假设有
m
m 堆果子，则进行
m
−
1
m−1 次合并操作后，所有果子都会被合并成同一堆。
智乃想知道她把这些果子合并成一堆的最小代价之和是多少。由于答案可能很大，请将答案对
(
1
0
9
+
7
)
(10
9
 +7) 取模后输出。
输入描述:
第一行输入一个正整数
n
(
1
≤
n
≤
1
0
5
)
n(1≤n≤10
5
 )，表示果子的种类数。
此后
n
n 行，第
i
i 行输入两个正整数
c
i
,
w
i
(
1
≤
c
i
,
w
i
≤
1
0
6
)
c
i
​
 ,w
i
​
 (1≤c
i
​
 ,w
i
​
 ≤10
6
 )，表示第
i
i 种果子的个数和重量。
输出描述:
仅一行一个正整数，表示将所有果子合并成一堆的最小代价之和，对
(
1
0
9
+
7
)
(10
9
 +7) 取模后的结果。
示例1
输入
复制
3
2 1
1 3
1 4
输出
复制
16
说明
在这个样例中，初始时共有
4
4 堆果子，重量分别为
{
1
,
1
,
3
,
4
}
{1,1,3,4}。一种可行的合并方案是：
∙
 
∙合并重量为
1
1 的两堆果子，代价为
2
2，场上剩下的果子重量为
{
2
,
3
,
4
}
{2,3,4}；
∙
 
∙合并重量为
2
2 和
3
3 的两堆果子，代价为
5
5，场上剩下的果子重量为
{
4
,
5
}
{4,5}；
∙
 
∙合并重量为
4
4 和
5
5 的两堆果子，代价为
9
9，场上剩下的果子重量为
{
9
}
{9}；
综上，总代价为
2
+
5
+
9
=
16
2+5+9=16。
示例2
输入
复制
1
1 1
输出
复制
0
说明
注意如果不需要合并，则代价为
0
0。
*
#include<iostream>
#include<queue>
using namespace std;
const int mod_ = 1e9 + 7;
struct H {
    int sh, po;
    bool operator>(const H& k)const {
        if (po != k.po)return po > k.po;
        else return sh > k.sh;
    }
    H operator+(const H& k) {
        return { sh + k.sh,po + k.po };
    }
}h;
int main()
{
    int n, c, w;
    long long m = -1, num = 0;
    priority_queue<H, vector<H>, greater<H>>q;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        cin >> c >> w;
        m += c;
        for (int j = 0; j < c; j++)
            q.push({ w % mod_,w / mod_ });
    }
    for (long long i = 0; i < m; i++)
    {
        h = q.top();
        q.pop();
        h = h + q.top();
        q.pop();
        q.push(h);
        num += h.sh, num %= mod_;
    }
    cout << num << endl;

    return 0;
}
*/

/* E
智乃的最大子段和取模

题目描述
对于一个长度为
n
n 的数组
a
0
,
a
1
,
⋯
 
,
a
n
−
1
a
0
​
 ,a
1
​
 ,⋯,a
n−1
​
 ，给定
l
,
r
(
0
≤
l
≤
r
<
n
)
l,r(0≤l≤r<n)，定义
sum
(
l
,
r
)
=
∑
i
=
l
r
a
i
sum(l,r)=
i=l
∑
r
​
 a
i
​
  为数组
a
a 的子段和。如果
l
′
,
r
′
l
′
 ,r
′
  是使
sum
(
l
,
r
)
sum(l,r) 在所有
l
,
r
l,r 的取值中达到了最大值，则称
sum
(
l
′
,
r
′
)
sum(l
′
 ,r
′
 ) 是最大子段和。

现在给定一个常数
p
p，智乃想要知道，如果在求得最大子段和的过程中对
p
p 取模，那么取模后数组整体的最大子段和应该是多少？
形式化的：记
S
(
l
,
r
)
=
sum
(
l
,
r
)
 
m
o
d
 
p
=
(
∑
i
=
l
r
a
i
)
 
m
o
d
 
p
S(l,r)=sum(l,r)modp=(
i=l
∑
r
​
 a
i
​
 )modp，请找到一对
l
′
,
r
′
l
′
 ,r
′
  使得
S
(
l
,
r
)
S(l,r) 成为最大值，输出
l
′
l
′
 、
r
′
r
′
 、这个最大值。如果有多种可行的答案，你可以输出任意符合条件的
l
′
,
r
′
l
′
 ,r
′
 。

请注意：本题需要输出在计算过程中取模后的子段和的最大值，而不是传统意义上的最大子段和对答案取模。

【名词解释】
 
m
o
d
 
mod：代表取模运算。例如，
5
5 除以
3
3 的余数为
2
2，因此式子
5
 
m
o
d
 
3
5mod3 的值为
2
2。
输入描述:
第一行输入两个正整数
n
,
p
(
1
≤
n
≤
1
0
5
;
 
1
≤
p
≤
1
0
9
)
n,p(1≤n≤10
5
 ;1≤p≤10
9
 )，表示数组的长度、模数。
第二行输入
n
n 个非负整数
a
0
,
a
1
,
…
,
a
n
−
1
(
0
≤
a
i
<
p
)
a
0
​
 ,a
1
​
 ,…,a
n−1
​
 (0≤a
i
​
 <p)，表示数组中的元素。
输出描述:
在一行中输出三个整数，分别表示
l
′
l
′
 、
r
′
r
′
 、取模后的最大子段和。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
5 10
6 9 1 9 1
输出
复制
1 3 9
说明
在这个样例中，注意下标从
0
0 开始计算，
(
a
1
+
a
2
+
a
3
)
 
m
o
d
 
10
=
(
9
+
1
+
9
)
 
m
o
d
 
10
=
9
(a
1
​
 +a
2
​
 +a
3
​
 )mod10=(9+1+9)mod10=9。
示例2
输入
复制
5 10
4 7 2 7 9
输出
复制
0 4 9
*/

/* F
智乃的算法竞赛群友

题目描述
智乃加了一个算法竞赛群，她发现里面的群友个个都是人才，说话又好听。
她发现每次管理员 qcjj 在发比赛链接时，群友都会往下复读什么 qcjjkkt（清楚姐姐看看题）和 td（题单）。

https://uploadfiles.nowcoder.com/images/20251210/0_1765337055252/A6E6FE4D738546984A4396CBF0061A7F
https://uploadfiles.nowcoder.com/images/20251210/0_1765337069687/B36BEC30EB78B228A823610FB73927C9

现在你想要在群里发言，具体来讲，你希望使用
n
n 个字符组成一句话。
这句话可以视为是一个长度为
n
n 的字符串，其每包含一个
qcjjkkt
qcjjkkt 子串，你获得
a
a 的快乐值，每包含一个
td
td 子串，获得
b
b 的快乐值。问能够在群中通过这次发言得到的最大快乐值是多少。
注意子串可以包含公共部分，例如
qcjjkktd
qcjjkktd 可以同时包含
qcjjkkt
qcjjkkt 和
td
td。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≤
T
≤
1
0
5
)
T(1≤T≤10
5
 ) 代表数据组数，每组测试数据描述如下：

在一行上输入三个正整数
n
,
a
,
b
(
1
≤
n
,
a
,
b
≤
1
0
9
)
n,a,b(1≤n,a,b≤10
9
 )，表示这句话的长度、包含
qcjjkkt
qcjjkkt 子串可以获得的快乐值、包含
td
td 子串可以获得的快乐值。
输出描述:
对于每组测试数据，新起一行输出一个整数，表示能够通过这次发言得到的最大快乐值。
示例1
输入
复制
3
10 9 1
1000000000 1000000000 1000000000
1 1 4
输出
复制
11
500000000000000000
0
*
#include<iostream>
using namespace std;
int main()
{
    long long t, n, a, b, c, num;
    double x, y, z;
    cin >> t;
    while (t--)
    {
        cin >> n >> a >> b;
        c = a + b;
        x = a / 7.0, y = b / 2.0, z = c / 8.0;


        cout << 0 << endl;
    }

    return 0;
}
*/

/* G √
智乃的箭头魔术

题目描述
本题为直接提交答案类型题目，后台仅有一组测试数据且与题目中给出的输入完全相同，您可以在本地通过各种方式得出答案，建议在提交语言中选择PHP直接提交答案的内容而不必编写一个输出答案的程序。

智乃有一张长度为
2
2 单位、宽度为
1
1 单位的纸，在上面画了两个箭头，如下图所示：

https://uploadfiles.nowcoder.com/images/20251018/0_1760755509957/4B6200CC43D409A3EAA4CE2A427DD933

智乃现在将这张纸沿虚线将右侧图形对折到左边，并且用胶水将这两个箭头黏在一起，并且在整个过程中保持左侧图形不动，使其成为一个正反两面的正方形折纸玩具，如下图所示：

https://uploadfiles.nowcoder.com/images/20251018/0_1760757110492/0E9473D4BBAC1590E4378CCD4974865F

假设该折纸玩具的初始状态为箭头指向右上方向（注意无论正反哪一面都是等价的），定义
6
6 种操作从
0
0 到
5
5，操作数的定义如下：
∙
 
∙操作
0
0，表示该折纸玩具按照中垂线（垂直对称轴）翻转（如图所示 '|' 形的竖线）；
∙
 
∙操作
1
1，表示该折纸玩具按照主对角线翻转（如图所示 '/' 形的对角线）；
∙
 
∙操作
2
2，表示该折纸玩具按照水平线翻转（如图所示 '-' 形的横线）；
∙
 
∙操作
3
3，表示该折纸玩具按照副对角线翻转（如图所示 '\' 形的对角线）；
∙
 
∙操作
4
4，表示该折纸玩具顺时针旋转
90
90 度；
∙
 
∙操作
5
5，表示该折纸玩具逆时针旋转
90
90 度。
所有翻转轴与旋转方向均相对于观察者的固定空间参考系，不随纸张的变换而改变。

接下来，智乃将进行
100
100 次操作，每次操作完成后，智乃都会询问你当前箭头的状态，状态即在某次操作后，箭头的朝向，如下图所示：
∙
 
∙
0
0 代表右上；
∙
 
∙
1
1 代表右下；
∙
 
∙
2
2 代表左下；
∙
 
∙
3
3 代表左上。

https://uploadfiles.nowcoder.com/images/20251018/0_1760757640651/00F9BE5A767030DC3DC55DA1503993AD

例如，假设智乃的操作序列是：
012345
那么你应该回答：
310232

现在具体的
100
100 次真实操作序列如下：
0112233445142015320125410214530214510214102302142025101203201451451522302514203214510021454101002532
你需要输出一个长度为
100
100 的字符串，第
i
i 位表示执行完前
i
i 次操作后箭头的状态。
输入描述:
本题不需要处理输入，判题时也不会提供任何程序输入。
输出描述:
在一行上输出一个长度为
100
100、仅包含数字
{
0
,
1
,
2
,
3
}
{0,1,2,3} 的字符串，表示智乃每次操作完成后箭头的状态。

建议在提交语言中选择PHP直接提交答案的内容而不必编写一个输出答案的程序。
备注:

*
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int n = 0, a[4][6] = {
        {3,0,1,2,1,3},
        {2,3,0,1,2,0},
        {1,2,3,0,3,1},
        {0,1,2,3,0,2}
    };
    string s = "0112233445142015320125410214530214510214102302142025101203201451451522302514203214510021454101002532";
    for (char c : s)
        n = a[n][c - '0'], cout << n;

    return 0;
}
*/

/* H
智乃的矩阵

题目描述
智乃有一个
n
n 行
n
n 列的正方形矩阵，矩阵的每一个元素都是一个整数，即可以看成是一个长和宽分别为
n
n 行
n
n 列的二维数组。
智乃现在有一个操作：选择一个
2
2 行
2
2 列的连续子矩阵，然后选择该子矩阵中两对互不重叠的相邻数字（即两对水平相邻数字，或两对垂直相邻数字），令其中一对的两个数字均增加
1
1，另一对的两个数字均减少
1
1。
智乃可以无限次的使用（也可以不使用）这个操作，她现在想令整个矩阵中所有的数字都变成相同的值，问她是否可以达成要求。
输入描述:
第一行输入一个正整数
n
(
1
≤
n
≤
400
)
n(1≤n≤400)，表示矩阵的大小。
此后
n
n 行，第
i
i 行输入
n
n 个整数
a
i
,
1
,
a
i
,
2
,
…
,
a
i
,
n
(
−
1
0
9
≤
a
i
,
j
≤
1
0
9
)
a
i,1
​
 ,a
i,2
​
 ,…,a
i,n
​
 (−10
9
 ≤a
i,j
​
 ≤10
9
 )，表示矩阵第
i
i 行的数字。
输出描述:
如果可以达到要求，则输出
Yes
Yes；否则输出
No
No。
示例1
输入
复制
2
1 1
-1 -1
输出
复制
Yes
示例2
输入
复制
4
1 0 0 -1
0 -1 0 -1
0 0 0 0
1 1 0 0
输出
复制
Yes
说明
在这个样例中，一种可行方案为：
[
1
0
0
−
1
0
−
1
0
−
1
0
0
0
0
1
1
0
0
]
⟶
[
1
0
−
1
0
0
−
1
−
1
0
0
0
0
0
1
1
0
0
]
Step 1
Step 2
↓
[
1
−
1
0
0
0
−
2
0
0
1
1
0
0
0
0
0
0
]
⟵
[
1
−
1
0
0
0
−
2
0
0
0
0
0
0
1
1
0
0
]
Step 4
Step 3
↓
[
1
−
1
0
0
1
−
1
0
0
0
0
0
0
0
0
0
0
]
⟶
[
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
0
]
Step 5
Step 6
⎣
⎢
⎢
⎡
​

1
0
0
1
​

0
−1
0
1
​

0
0
0
0
​

−1
−1
0
0
​

⎦
⎥
⎥
⎤
​

Step 1
⎣
⎢
⎢
⎡
​

1
0
1
0
​

−1
−2
1
0
​

0
0
0
0
​

0
0
0
0
​

⎦
⎥
⎥
⎤
​

Step 4
↓
⎣
⎢
⎢
⎡
​

1
1
0
0
​

−1
−1
0
0
​

0
0
0
0
​

0
0
0
0
​

⎦
⎥
⎥
⎤
​

Step 5
​

⟶
⟵
⟶
​

⎣
⎢
⎢
⎡
​

1
0
0
1
​

0
−1
0
1
​

−1
−1
0
0
​

0
0
0
0
​

⎦
⎥
⎥
⎤
​

Step 2
↓
⎣
⎢
⎢
⎡
​

1
0
0
1
​

−1
−2
0
1
​

0
0
0
0
​

0
0
0
0
​

⎦
⎥
⎥
⎤
​

Step 3
⎣
⎢
⎢
⎡
​

0
0
0
0
​

0
0
0
0
​

0
0
0
0
​

0
0
0
0
​

⎦
⎥
⎥
⎤
​

Step 6
​

示例3
输入
复制
4
1 1 -1 0
-1 0 -1 0
1 1 -1 0
0 0 0 0
输出
复制
No
示例4
输入
复制
1
114514
输出
复制
Yes
*/

/* I
智乃挖坑

题目描述
泰拉瑞亚是一款2D沙盒游戏，在游戏中玩家可以在游戏中做很多事情：制造武器战胜各种各样的敌人及群落；
挖掘地下寻找器材配件、金钱和其他有用的东西；收集木材，石材，矿石等资源；用世界里的一切创造你需要的东西并守护它。
在游戏中，玩家一开始位于水平地面，地面可以视为是一个一维数轴，且最左边的坐标是 1，最右侧的坐标是 n。初始时，地面所有位置的深度均为 0。
智乃想通过 m 次连续操作在游戏中向下挖一个大坑，具体来讲，在第 i 次操作中会输入一个坐标 pi 以及向下的力度 fi ，然后，对于所有整数坐标 j(1≤j≤n)，深度增加 max(fi−∣j−pi∣,0)。

https://uploadfiles.nowcoder.com/images/20250210/0_1739161694502/54720E1A0961412DED2C5296384E8A88

例如上图是一次操作 f=3 时的示意图。

连续操作时会使得每个位置上的影响叠加求和。
假设现在游戏向下的地图边界深度为 h，一旦玩家向下挖坑的过程中，某个位置的深度大于 h，就会挖出地图边界。

现在智乃想知道她在 m 次向下挖坑的过程中是否存在挖出地图边界的情况，如果存在，则告诉智乃她最早在第几次操作时挖出了地图边界。

输入描述:
第一行输入三个正整数 n,m,h(1≤n,m≤2×10^5;1≤h≤10^18)，表示水平地面的长度、操作次数、挖坑的深度限制。
此后 m 行，第 i 行输入两个正整数 (1≤pi≤n;1≤fi≤10^9)，表示第 i 次操作的参数。

输出描述:
如果智乃不会挖出地图的边界，直接输出 No；
否则，第一行输出 Yes，第二行输出一个整数，表示她是在第几次操作的时候挖出的地图边界。

示例1
输入
3 3 2
1 2
3 2
2 1

输出
Yes
3


示例2
输入
3 3 3
1 2
3 2
2 1

输出
No

备注:
在几乎全部的情况下，PyPy 的运行速度优于 Python，我们建议您选择对应版本的 PyPy 进行提交、而不是 Python。
*/

/* J √
智乃的幻方

题目描述
如果一个 3 行 3 列的矩阵的行、列、两条对角线上的数字之和相同，且 9 个位置上的数字为 1−9 出现各一次，则称这个 3 行 3 列的矩阵为一个三阶幻方。

现在智乃有一个 3 行 3 列的矩阵，请你告诉她这个矩阵是否满足幻方的条件，如果满足输出 Yes，否则输出 No。

输入描述:
一共三行，第 i 行输入三个正整数 a(i,1),a(i,2),a(i,3)(1≤a(i,j)≤9)，表示矩阵第 i 行的数字。

输出描述:
如果矩阵满足条件，输出 Yes；
否则输出 No。

示例1
输入
8 1 6
3 5 7
4 9 2

输出
Yes


示例2
输入
1 2 3
4 5 6
7 8 9

输出
No
*/
#include<iostream>
using namespace std;
int main()
{
    int a[4][4] = { 0 };
    bool u = 1, v[10] = { 0 };
    for (int i = 1; i <= 3; i++)
        for (int j = 1; j <= 3; j++)
            cin >> a[i][j], a[0][j] += a[i][j], a[i][0] += a[i][j], v[a[i][j]] = 1;
    for (int i = 1; i <= 9; i++)
        u &= v[i];
    for (int i = 1; u && i <= 3; i++)
        u = a[0][i] == a[i][0];
    cout << (u && a[1][1] + a[3][3] == a[3][1] + a[1][3] ? "Yes" : "No") << endl;

    return 0;
}
