//链接：https://ac.nowcoder.com/acm/contest/
//来源：牛客网
/* A
智乃的二进制

题目描述
智乃定义一个十进制正整数是“好”的，当且仅当其十进制表示中仅包含数字
0
0 和
1
1，且数字
1
1 的出现次数不超过
2
2。其十进制表示对应的字符串是其二进制表示对应的字符串的一个后缀。
例如：
101
101（10进制），其中只有
2
2 个数位为
1
1，转写成二进制为
1100101
1100101（2进制），其二进制包含后缀
101
101，就说它是“好”的。
前
9
9 个“好”数分别为：
1
1、
10
10、
11
11、
100
100、
101
101、
110
110、
1000
1000、
1001
1001、
1100
1100。

现在智乃想要知道，从小到大排列后的第
𝑘
k 个符合条件的“好”数是多少。由于答案可能很大，请将答案对
(
1
0
9
+
7
)
(10
9
 +7) 取模后输出。

【名词解释】
字符串的后缀：从字符串的最后一个字符开始，向前连续取若干个字符得到的字符串。更具体地，字符串
𝑠
s 后
𝑖
i 个字符构成的字符串被称为
𝑠
s 的第
𝑖
i 个后缀，也记为
𝑠
[
𝑛
−
𝑖
+
1..
𝑛
]
s[n−i+1..n]。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
𝑇
(
1
≤
𝑇
≤
1
0
4
)
T(1≤T≤10
4
 ) 代表数据组数，每组测试数据描述如下：

输入一个正整数
𝑘
(
1
≤
𝑘
≤
1
0
18
)
k(1≤k≤10
18
 )，表示要查询的第
𝑘
k 个“好”数。
输出描述:
对于每一组测试数据，新起一行输出一个整数，表示答案对
(
1
0
9
+
7
)
(10
9
 +7) 取模后的结果。
示例1
输入
复制
10
1
2
3
4
5
6
7
8
9
114514
输出
复制
1
10
11
100
101
110
1000
1001
1100
722497934
说明
注意第
9
9 个符合条件的数字不是
1010
1010，因为
1010
1010 的二进制表示为
1111110010
1111110010，不符合条件。
*
#include<iostream>
#include<cmath>
using namespace std;
const long long mod_ = 1e9 + 7;
inline long long pow10(long long n)
{
    long long res = 1, base = 10;
    while (n > 0)
    {
        if (n % 2)res = (res * base) % mod_;
        base = (base * base) % mod_;
        n /= 2;
    }
    return res;
}
int main()
{
    long long t, k, n, m;
    cin >> t;
    while (t--)
    {
        cin >> k;
        n = sqrt(k * 2) + 0.5;
        m = k - n * (n - 1) / 2 - 1;
        cout << (pow10(n - 1) + (long long)(pow10(m) / 10)) % mod_ << endl;
    }

    return 0;
}
*/

/* B √
智乃的瓷砖

题目描述
智乃想要在他家的浴室密铺一种菱形图案的瓷砖，具体来讲，她现在有两种不同图案的瓷砖，一种是 "/"（斜杠）形状，另一种是 "\"（反斜杠）形状的。
假设她家的墙面可以看做是一个
n
n 行
m
m 列的二维字符矩阵，现在规定其左上角的形状为 "/" 型，且每一对上下相邻、左右相邻的瓷砖均形状不同。

例如，下面这个字符矩阵就是一个
6
×
10
6×10 的图形：
/\/\/\/\/\
\/\/\/\/\/
/\/\/\/\/\
\/\/\/\/\/
/\/\/\/\/\
\/\/\/\/\/
请你告诉智乃这面墙在铺好瓷砖后的形状应该是怎样的。
输入描述:
在一行上输入两个正整数
n
,
m
(
1
≤
n
,
m
≤
100
)
n,m(1≤n,m≤100)，表示智乃家墙面的行数、列数。
输出描述:
请输出一个
n
n 行
m
m 列的字符矩阵，表示墙面的形状。
示例1
输入
复制
1 1
输出
复制
/
示例2
输入
复制
6 10
输出
复制
/\/\/\/\/\
\/\/\/\/\/
/\/\/\/\/\
\/\/\/\/\/
/\/\/\/\/\
\/\/\/\/\/
*
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int n, m;
    char a[2] = { '/','\\' };
    bool u;
    cin >> n >> m;
    for (int i = 0; i < n; i++)
    {
        u = i % 2;
        for (int j = 0; j < m; j++)
            cout << a[u], u = !u;
        cout << endl;
    }

    return 0;
}
*/

/* C
智乃的草坪

题目描述
智乃有一块矩形草坪，从地图正上方俯视，草坪的四个端点分别位于坐标
(
0
,
r
)
(0,r)、
(
0
,
−
r
)
(0,−r)、
(
c
,
r
)
(c,r)、
(
c
,
−
r
)
(c,−r)。
现在智乃有
n
n 个自动洒水装置，第
i
i 个洒水装置位于坐标
(
p
i
,
0
)
(p
i
​
 ,0) 上，浇水速率为
v
i
v
i
​
 ，保证洒水装置的坐标一定位于草坪内部或边缘。
当这些洒水装置启动，
t
t 个时间单位以后，第
i
i 个洒水装置洒水的范围是一个以坐标
(
p
i
,
0
)
(p
i
​
 ,0) 为圆心，以
v
i
×
t
v
i
​
 ×t 为半径的圆。
当经过
t
t 个时间单位以后，所有洒水装置洒水的范围覆盖了整个草坪的矩形，就说明智乃完成了她的浇水工作。更具体地，若矩形区域内的所有点
(
x
,
y
)
(x,y) 满足
0
≤
x
≤
c
0≤x≤c 且
−
r
≤
y
≤
r
−r≤y≤r 均被至少一个启动的圆覆盖，则称完成了浇水工作。

现在由于电力紧缺，智乃发现他至多只能启动其中的
k
k 个洒水装置。问智乃完成整个草坪洒水工作的最短时间是多少。显然，在经历足够长的时间后，即使只使用
1
1 个洒水器也能完成工作，所以答案一定存在。
输入描述:
第一行输入四个非负整数
n
,
k
,
r
,
c
(
1
≤
n
≤
1
0
5
;
 
1
≤
k
≤
n
;
 
1
≤
r
,
c
≤
1
0
6
)
n,k,r,c(1≤n≤10
5
 ;1≤k≤n;1≤r,c≤10
6
 )，分别表示总共的洒水装置数、最多启动的洒水装置数、草坪的一半高度和宽度。
此后
n
n 行，第
i
i 行输入两个整数
p
i
,
v
i
(
0
≤
p
i
≤
c
;
 
1
≤
v
i
≤
1
0
4
)
p
i
​
 ,v
i
​
 (0≤p
i
​
 ≤c;1≤v
i
​
 ≤10
4
 )，表示第
i
i 个洒水装置的坐标和洒水速率。
输出描述:
输出一个实数，表示最短工作时间。

由于实数的计算存在误差，当误差的量级不超过
1
0
−
4
10
−4
  时，您的答案都将被接受。具体来说，设您的答案为
a
a，标准答案为
b
b，当且仅当
∣
a
−
b
∣
max
⁡
(
1
,
∣
b
∣
)
≤
1
0
−
4
max(1,∣b∣)
∣a−b∣
​
 ≤10
−4
  时，您的答案将被接受。
示例1
输入
复制
2 1 10 1000000
0 114
1000000 514
输出
复制
1945.52529193
示例2
输入
复制
2 2 10 1000000
0 114
1000000 514
输出
复制
1592.35668843
示例3
输入
复制
2 2 200000 1000000
0 114
1000000 514
输出
复制
1853.90929144
说明
在这个样例中，如图所示，深绿色重合部分为草坪范围。
https://uploadfiles.nowcoder.com/images/20260211/0_1770800665419/48920B1D18A5C84BD50995ABE187C794

备注:
可以使用几何画板辅助完成本题：https://www.desmos.com/calculator?lang=zh-CN。
*/

/* D
智乃的最大子段和取模

题目描述
对于一个长度为
n
n 的数组
a
0
,
a
1
,
⋯
 
,
a
n
−
1
a
0
​
 ,a
1
​
 ,⋯,a
n−1
​
 ，给定
l
,
r
(
0
≤
l
≤
r
<
n
)
l,r(0≤l≤r<n)，定义
sum
(
l
,
r
)
=
∑
i
=
l
r
a
i
sum(l,r)=
i=l
∑
r
​
 a
i
​
  为数组
a
a 的子段和。如果
l
′
,
r
′
l
′
 ,r
′
  是使
sum
(
l
,
r
)
sum(l,r) 在所有
l
,
r
l,r 的取值中达到了最大值，则称
sum
(
l
′
,
r
′
)
sum(l
′
 ,r
′
 ) 是最大子段和。

现在给定一个常数
p
p，智乃想要知道，如果在求得最大子段和的过程中对
p
p 取模，那么取模后数组整体的最大子段和应该是多少？
形式化的：记
S
(
l
,
r
)
=
sum
(
l
,
r
)
 
m
o
d
 
p
=
(
∑
i
=
l
r
a
i
)
 
m
o
d
 
p
S(l,r)=sum(l,r)modp=(
i=l
∑
r
​
 a
i
​
 )modp，请找到一对
l
′
,
r
′
l
′
 ,r
′
  使得
S
(
l
,
r
)
S(l,r) 成为最大值，输出
l
′
l
′
 、
r
′
r
′
 、这个最大值。如果有多种可行的答案，你可以输出任意符合条件的
l
′
,
r
′
l
′
 ,r
′
 。

请注意：本题需要输出在计算过程中取模后的子段和的最大值，而不是传统意义上的最大子段和对答案取模。

【名词解释】
 
m
o
d
 
mod：代表取模运算。例如，
5
5 除以
3
3 的余数为
2
2，因此式子
5
 
m
o
d
 
3
5mod3 的值为
2
2。
输入描述:
第一行输入两个正整数
n
,
p
(
1
≤
n
≤
1
0
5
;
 
1
≤
p
≤
1
0
9
)
n,p(1≤n≤10
5
 ;1≤p≤10
9
 )，表示数组的长度、模数。
第二行输入
n
n 个非负整数
a
0
,
a
1
,
…
,
a
n
−
1
(
0
≤
a
i
<
p
)
a
0
​
 ,a
1
​
 ,…,a
n−1
​
 (0≤a
i
​
 <p)，表示数组中的元素。
输出描述:
在一行中输出三个整数，分别表示
l
′
l
′
 、
r
′
r
′
 、取模后的最大子段和。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
5 10
6 9 1 9 1
输出
复制
1 3 9
说明
在这个样例中，注意下标从
0
0 开始计算，
(
a
1
+
a
2
+
a
3
)
 
m
o
d
 
10
=
(
9
+
1
+
9
)
 
m
o
d
 
10
=
9
(a
1
​
 +a
2
​
 +a
3
​
 )mod10=(9+1+9)mod10=9。
示例2
输入
复制
5 10
4 7 2 7 9
输出
复制
0 4 9
*/

/* F √

*/

/* E √

*/
