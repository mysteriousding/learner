/*
九宫幻方

题目描述
小明最近在教邻居家的小朋友小学奥数，而最近正好讲述到了三阶幻方这个部分，三阶幻方指的是将 1~9 不重复的填入一个 3*3 的矩阵当中，使得每一行、每一列和每一条对角线的和都是相同的。

三阶幻方又被称作九宫格，在小学奥数里有一句非常有名的口诀：
"二四为肩，六八为足，左三右七，戴九履一，五居其中"，通过这样的一句口诀就能够非常完美的构造出一个九宫格来。

4 9 2

3 5 7

8 1 6

有意思的是，所有的三阶幻方，都可以通过这样一个九宫格进行若干镜像和旋转操作之后得到。
现在小明准备将一个三阶幻方（不一定是上图中的那个）中的一些数抹掉，交给邻居家的小朋友来进行还原，并且希望她能够判断出究竟是不是只有一个解。

而你呢，也被小明交付了同样的任务，但是不同的是，你需要写一个程序。

输入描述
输入仅包含单组测试数据。

每组测试数据为一个 3*3 的矩阵，其中为 0 的部分表示被小明抹去的部分。

给出的矩阵至少能还原出一组可行的三阶幻方。

输出描述
如果仅能还原出一组可行的三阶幻方，则将其输出，否则输出"Too Many"（不包含引号）。

输入输出样例
示例
输入

0 7 2
0 5 0
0 3 0

输出

6 7 2
1 5 9
8 3 4
*/
#include <iostream>
using namespace std;
int N[3][3];
bool M[10];
bool pd()
{
    if ()
}
bool dfs(int x)
{
    if (x >= 9)
    {
        if (pd(int x))
    }
}
int main()
{
    int n = -1, m = -1;
    bool u = 0;
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
        {
            cin >> N[i][j];
            M[N[i][j]] = 1;
            if (!(i == 1 && j == 1) && N[i][j])
                n = i, m = j;
        }
    for (int i = 0; i < 3; i++)
        for (int j = 0; j < 3; j++)
            if (!(i == 1 && j == 1) && !(i == n && j == m) && !(i + n == 2 && j + m == 2) && N[i][j])
            {
                u = 1;
                break;
            }
    if (u)
    {
        dfs(1);
    }
    else cout << "Too Many" << endl;


    return 0;
}
