/*(1)策反加州

//题目描述
//来年一月份，特朗普将再次入主白宫，然而他却花了不少钱，这个时候，小 m 想知道，如果要让特朗普胜选，最少应该花多少钱。
//
//因此，小 m 查询了美国选举制度，发现选举有以下几种形式：
//
//一部分州在拿下一个州的一半及以上选民之后，即获得选票数要大于等于总票数的一半，就可以获得这个州的全部 M 张选举人票。
//
//一部分州在则会按照比例分配，即会获得（选举人票数 N× 自己获得的票数/该州所有选票数）下取整后的票数。
//
//还有一部分州会采取如果选票超过或等于一半，即获得选票数要大于等于总票数的一半，则会获得固定的 M 张选举人票，其余还有 N 张选举人票按照比例分配，与第二种情况类似。
//
//特朗普需要获得 w 的选票，或者获得或者超过 w 张选票，即可当选，而对于每个州而言，我们发现每多花 x 美元就可以使一个选民选择特朗普，
//请问，最小花费是多少，数据保证如果按照比例分配，则选民人数可以被选举人票数整除。
//
//输入格式
//第一行输入两个数个数 t，w，表示美国州的个数和获胜需要的选票数。
//
//接下来 t 行，每行包含 4 个整数 N,M,p,x，分别表示按照一半以上分配的选举人票数，按照比例分配的选举人票数，选民总人数，在该州每收获一个选民需要的费用。
//显然，如果 N=0，则为第一种情况，如果 M=0，则为第二种情况，其余状况均为第三章情况。
//
//输出格式
//输出一行一个数，表示特朗普当选总统所需要的最小花费。
//
//数据范围和约定
//t≤10^3 ,w≤10^4 ,1≤N+M≤10^4 ,N≥0,M≥0,p≤10^5 ,x<=10^9 ,p%N=0。
//
//输入输出样例
//输入样例 1
//5 21
//6 4 12 100
//3 2 9 100
//5 0 5 180
//0 6 10 150
//11 3 99 100
//输出样例 1
//2670
//样例解释 1
//总共有 40 张选票，我们先花 750 美元获得第 4 个州的全部选票 6 张，
//再花 600 美元获得第一个州 3 + 4 张选票，
//再花 720 美元获得第 3 个州的 4 张选票，
//最后耗费 600 美元获得第二个州的 2 + 2 张选票，
//共 21 张选票，花费 2570 元获得总统职位。

#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
struct zhou
{
    int n;
    int m;
    int p;
    int x;
};

int main()
{
    int t,w,s,r,v;
    cin>>t>>w;
    vector<zhou>a(t);
    vector<int>dp(w+1,-1);
    dp[0]=0;
    for(int i=0;i<t;i++)
        cin>>a[i].n>>a[i].m>>a[i].p>>a[i].x;

    for(int k=0;k<t;k++)
    {
        vector<int>new_dp=dp;

        if(a[k].m>0)
            s=(a[k].p+1)/2*a[k].x;
            for(int i=0;i<=w;i++)
            {
                if(dp[i]==-1)continue;
                r=min(i+a[k].m,w);
                if(new_dp[r]==-1||new_dp[r]>dp[i]+s)
                    new_dp[r]=dp[i]+s;
            }

        if(a[k].n>0)
            for(int j=0;j<=a[k].p;j++)
            {
                s=j*a[k].x;
                v=0;
                if(a[k].m>0&&j>=(a[k].p+1)/2)
                    v=a[k].m+(a[k].n*j)/a[k].p;
                else v=(a[k].n*j)/a[k].p;

                if(v==0)continue;

                for(int i=w;i>=0;i--)
                {
                    if(dp[i]==-1)continue;
                    r=min(i+v,w);
                    if(new_dp[r]==-1||new_dp[r]>dp[i]+s)
                        new_dp[r]=dp[i]+s;
                }
            }

        dp.swap(new_dp);
    }
    cout<<dp[w]<<endl;

    return 0;
}
*/

/*(2)小游戏2.0

//题目描述
//在刷视频的时候，我们经常会遇到这种情况。
//我们看到一个小游戏广告。它会有 m 排每排 n 个数字，玩家手里有一个初始数字，并且从一个固定的位置出发，只能吃小于等于自己的数字，遇到大于它的数字就会输掉游戏。
//但是还演示的人经常会表现的十分的菜，以至于他经常通关不了游戏，这个时候你就想到能否使用代码能够算出如果每次走最优的情况下能最终能否通关。
//
//现在小 r 正在玩这个游戏，小 r 手速足够快，他可以瞬间碰到这一行的所有可以碰到的数字，但又由于小 r 手速过慢，他下一行只能从这一行最后一个吃到的数字的位置开始。
//
//小 r 想知道他手中的数字最后的值最大是多少。
//
//输入格式
//第一行一个数字 t，表示测试用例个数。
//
//对于每一个测试用例：
//
//第一行输入 4 个数字 n,m,x,p，分别表示每一行数字的个数，行数，初始值和初始位置。
//
//第二行一行输入 n 个数 ai ，表示每一行有哪些数字。
//
//输出格式
//一行一个数，表示答案。
//
//数据范围和约定
//t≤20, n≤2×10^5 ,m≤2×10^8 ,x ,ai≤2×10^5 。
//
//输入输出样例
//输入样例 1
//4
//4 10 1 1
//1 5 30 180
//4 10 1 3
//1 5 30 180
//10 10 1 5
//1000 200 2 6 1 5 2 3 4 400
//10 100 1 5
//1000 200 2 6 1 5 2 3 4 400
//输出样例 1
//136
//1
//165
//143635

#include<iostream>
#include<cstdio>
#include<vector>
using namespace std;
int main()
{
    std::ios::sync_with_stdio(false);
    int t,n,m,x,p,z,y;
    long long num,sum;
    vector<int>a;
    cin>>t;
    for(int k=0;k<t;k++)
    {
        cin>>n>>m>>x>>p;
        sum=x,z=p-1,y=p+1;
        a.resize(n+2,0);
        for(int i=1;i<=n;i++)
            cin>>a[i];
        if(a[p]>x){cout<<x<<endl;continue;}
        num=a[p];
        for(int j=0;j<m;j++)
        {
            sum+=num;
            while(z!=0||y!=n+1)
                if(z!=0&&a[z]<=sum)sum+=a[z],num+=a[z],z--;
                else if(y!=n+1&&a[y]<=sum)sum+=a[y],num+=a[y],y++;
                else break;
        }
        cout<<sum<<endl;
    }

    return 0;
}
*/
