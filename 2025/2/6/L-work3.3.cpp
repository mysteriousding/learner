/*(11)任务调度的合理性

//假定一个工程项目由一组子任务构成，子任务之间有的可以并行执行，有的必须在完成了其它一些子任务后才能执行。
//“任务调度”包括一组子任务、以及每个子任务可以执行所依赖的子任务集。
//
//比如完成一个专业的所有课程学习和毕业设计可以看成一个本科生要完成的一项工程，各门课程可以看成是子任务。有些课程可以同时开设，比如英语和 C 程序设计，它们没有必须先修哪门的约束；有些课程则不可以同时开设，因为它们有先后的依赖关系，比如 C 程序设计和数据结构两门课，必须先学习前者。
//
//但是需要注意的是，对一组子任务，并不是任意的任务调度都是一个可行的方案。比如方案中存在“子任务 a 依赖于子任务 b，子任务 b 依赖于子任务 c，子任务 c 又依赖于子任务 a”，那么这三个任务哪个都不能先执行，这就是一个不可行的方案。
//你现在的工作是写程序判定任何一个给定的任务调度是否可行。
//
//输入格式:
//输入说明：输入第一行给出子任务数 n（≤100），子任务按 1~$$n编号。随后n行，每行给出一个子任务的依赖集合：
//首先给出依赖集合中的子任务数k，随后给出k$$ 个子任务编号，整数之间都用空格分隔。
//
//输出格式:
//如果方案可行，则输出 1，否则输出 0。
//
//输入样例1:
//12
//0
//0
//2 1 2
//0
//1 4
//1 5
//2 3 6
//1 3
//2 7 8
//1 7
//1 10
//1 7
//输出样例1:
//1
//输入样例2:
//5
//1 4
//2 1 4
//2 2 5
//1 3
//0
//输出样例2:
//0

#include <iostream>
#include <vector>
#include <queue>
using namespace std;

bool pd(int n, vector<vector<int>>& d)
{
    vector<int> ru(n + 1, 0);
    vector<vector<int>> tu(n + 1);

    for (int i = 1; i <= n; ++i)
        for (int j : d[i])
        {
            tu[j].push_back(i);
            ru[i]++;
        }

    // Kahn 算法
    queue<int> q;
    for (int i = 1; i <= n; ++i)
        if (ru[i] == 0)
            q.push(i);

    int u = 0;
    while (!q.empty())
    {
        int num = q.front();
        q.pop();
        u++;

        for (int h : tu[num])
        {
            ru[h]--;
            if (ru[h] == 0)
                q.push(h);
        }
    }
    return u == n;
}

int main()
{
    int n;
    cin >> n;
    vector<vector<int>> a(n + 1);

    for (int i = 1; i <= n; ++i)
    {
        int k;
        cin >> k;
        for (int j = 0; j < k; ++j)
        {
            int dep;
            cin >> dep;
            a[i].push_back(dep);
        }
    }

    if (pd(n, a))cout << 1 << endl;
    else cout << 0 << endl;

    return 0;
}
*/

/*(12)基于贪心策略的离散背包问题近似算法

//离散背包问题（也称为“0-1 背包问题”）的定义是：
//给定一个总承重量为 W 的背包和 n 件物品的集合 S={s1 ,⋯,sn }，其中第 i 件物品有其重量 wi 和价值 vi。
//要求一种分派方案x =(x1 ,⋯,xn )，在满足约束条件 R:Σ(n,i=1) xi⋅ wi≤W（即装入的物品总重量不超过背包承重）的前提下，使优化函数 f(x)=Σ(n,i=1) xi⋅ vi 取极大值（即装入的物品总价值最大）。
//其中 xi 是整数，取值或为 1 或为 0，即每一件物品只有 2 种选择，或者完全放进背包，或者被完全舍弃。
//
//基于贪心策略的离散背包问题近似算法是分别利用按原价贪心（greedy by value）和按单价贪心（greedy by unit value）两种算法求出两组解，取两者中较优的解。
//本题就请你实现这个算法。
//
//输入格式：
//输入首先在第一行中给出正整数 n（≤1000）和正实数 W（≤500）。
//随后两行各给出 n 个不超过 2000 的正实数，分别为 n 件物品的重量和价值，即第一行第 i 个数字表示第 i 件物品的重量，第二行对应位置表示其价值。
//同行数字间以空格分隔。
//
//输出格式：
//首先在第一行输出装入物品的最大总价值，要求输出小数点后 2 位。
//随后一行输出最优分派方案的分量 (x1 ,⋯,xn )。
//简单起见，每个分量后面跟一个空格。
//
//输入样例：
//5 11.2
//1 2 5 6 7
//4 6 18 22 25.3
//输出样例：
//35.30
//1 1 0 0 1

#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
using namespace std;

struct Itm
{
    int id;
    double wt;
    double vl;
    double up;
};

bool cmpV(const Itm& a, const Itm& b)
{
    return a.vl > b.vl;
}

bool cmpP(const Itm& a, const Itm& b)
{
    return a.up > b.up;
}

pair<double, vector<int>> gk(int n, double W, const vector<Itm>& its, bool (*cmp)(const Itm&, const Itm&)) {
    vector<Itm> srt = its;
    sort(srt.begin(), srt.end(), cmp);

    double tv = 0.0; // 总价值
    vector<int> x(n, 0); // 分配方案
    double tw = W; // 剩余重量

    for (const auto& itm : srt)
        if (tw >= itm.wt)
        {
            x[itm.id] = 1;
            tv += itm.vl;
            tw -= itm.wt;
        }

    return {tv, x};
}

int main()
{
    int n;
    double W;
    cin >> n >> W;

    vector<Itm> its(n);
    for (int i = 0; i < n; ++i)
    {
        cin >> its[i].wt;
        its[i].id = i;
    }
    for (int i = 0; i < n; ++i)
    {
        cin >> its[i].vl;
        its[i].up = its[i].vl / its[i].wt;
    }

    auto [v1, x1] = gk(n, W, its, cmpV);
    auto [v2, x2] = gk(n, W, its, cmpP);

    pair<double, vector<int>> res;
    if (v1 >= v2) res = {v1, x1};
    else res = {v2, x2};

    cout << fixed << setprecision(2) << res.first << endl;
    for (int i = 0; i < n; ++i)
        cout << res.second[i] << " ";
    cout << endl;

    return 0;
}
*/

/*(13)基于动态规划的离散背包问题近似算法

//离散背包问题（也称为“0-1 背包问题”）的定义是：
//给定一个总承重量为 W 的背包和 n 件物品的集合 S={s1 ,⋯,sn }，其中第 i 件物品有其重量 wi 和价值 vi 。
//要求一种分派方案x =(x1 ,⋯,xn )，在满足约束条件 R:Σ(n,i=1) xi⋅ wi≤W（即装入的物品总重量不超过背包承重）的前提下，使优化函数 f(x)=Σ(n,i=1) xi⋅ vi 取极大值（即装入的物品总价值最大）。
//其中 xi 是整数，取值或为 1 或为 0，即每一件物品只有 2 种选择，或者完全放进背包，或者被完全舍弃。
//
//基于动态规划的离散背包问题近似算法的原理是对原始问题的物品价值进行缩放，然后调用动态规划算法处理缩放后具有较小整数价值的 0-1 背包问题。
//动态规划算法令 f[i][v] 存储前 i 个物品中选取总价值至少为 v 的物品，所需要的最小重量，最后找到重量在承重范围内的最大的 v 即可。
//
//这个算法的近似比为 (1+ϵ)，其中 0<ϵ≤1 是给定的精度要求。
//对应的缩放尺度因子为 θ=[ϵVmax/2n]，其中 Vmax 是所有物品价值中的最大值。
//在执行动态规划算法前，我们需要将所有物品的价值 v 缩放为 ⌈v/θ⌉。
//
//输入格式：
//输入首先在第一行中给出三个数字：正整数 n（≤10^2）、正整数 W（≤10^4）、精度要求 ϵ（0<ϵ≤1）。
//随后一行给出 n 个不超过 10^4 的正整数，依次为 n 件物品的重量；
//下一行给出 n 个不超过 10^5 的正整数，依次为 n 件物品的价值。
//同行数字间以空格分隔。
//
//注意：题目保证 Σ(n,i=1) vi ≤10^7 。
//
//输出格式：
//首先输出动态规划算法得到的精确解，随后输出近似算法得到的解。
//每组解的输出格式为：
//首先在第一行输出装入物品的最大总价值。
//随后一行输出最优分派方案的分量 (x1 ,⋯,xn )。
//简单起见，每个分量后面跟一个空格。
//
//注意：最优分配方案可能有多种，你只需要输出任意一种即可。
//
//输入样例：
//5 11 0.8
//1 2 5 6 7
//4221 9243 18000 22000 25987
//输出样例：
//40000
//0 0 1 1 0
//39451
//1 1 0 0 1


*/

/*(14)前t个组合结果

//组合结果
//
//找出从自然数1、2、... 、n（0<n<=30）中任取r(0<r<=n)个数的组合，输出其中前t个组合结果。
//
//输入格式:
//在一行中输入n、r、t（1<=t<=C(n,r））。
//
//输出格式:
//按特定顺序输出前t个组合结果，每一个组合结果占一行，含第一个整数在内的每一个整数前面都用一个空格，最后一个整数后面没有空格。
//特定顺序：每一个组合结果中的值从大到小排列，组合之间按逆字典序排列。
//
//输入样例:
//在这里给出一组输入。例如：
//
//5 3 10
//
//6 4 8
//
//输出样例:
//在这里给出相应的输出。例如：
//
// 5 4 3
// 5 4 2
// 5 4 1
// 5 3 2
// 5 3 1
// 5 2 1
// 4 3 2
// 4 3 1
// 4 2 1
// 3 2 1
//
// 6 5 4 3
// 6 5 4 2
// 6 5 4 1
// 6 5 3 2
// 6 5 3 1
// 6 5 2 1
// 6 4 3 2
// 6 4 3 1

#include<iostream>
using namespace std;
int n,r,t,num=0;
int a[30];
bool l[33];
void dfs(int x,int y)
{
    if(x>r)
    {
        for(int i=1;i<=r;i++)
            cout<<" "<<a[i];
        cout<<endl;
        num++;
        if(num==t)l[0]=1;
        return;
    }
    for(int i=y;i>=1;i--)
        if(!l[i])
        {
            a[x]=i;
            l[i]=1;
            dfs(x+1,i-1);
            l[i]=0;
            if(l[0])return;
        }
}
int main()
{
    cin>>n>>r>>t;
    dfs(1,n);

    return 0;
}



// #include<iostream>
// #include<string>
// using namespace std;
// int n,r,t,num;
// string m;
// bool l[33];
// void dfs(int x,int y)
// {
//     if(x>2*r-1)
//     {
//         cout<<m<<endl;
//         num++;
//         if(num==t)l[0]=1;
//         return;
//     }
//     for(int i=y;i>=1;i--)
//         if(!l[i])
//         {
//             m[x]=char(i+'0');
//             l[i]=1;
//             dfs(x+2,i-1);
//             l[i]=0;
//             if(l[0])return;
//         }
// }
// int main()
// {
//     while(cin>>n>>r>>t)
//     {
//         num=0,m="";
//         for(int i=0;i<=n+1;i++)
//             l[i]=0;
//         for(int i=0;i<r;i++)
//             m+=" 0";
//         dfs(1,n);
//     }
//     return 0;
// }
*/

//树上的数
//
// https://images.ptausercontent.com/c35b1529-fcfd-4753-853f-b736fdadf374.png
// https://images.ptausercontent.com/46e3494f-47c8-454c-b914-edf4e1072b21.png
// https://images.ptausercontent.com/b80c3bcd-645a-492f-8736-a43b8a00e86c.png
// 
//给定一个大小为n的树，它共有n个结点与n-1条边，结点从1~n编号。
//初始时每个结点上都有一个1~n的数字，且每个1~n的数字都只在恰好一个结点上出现。
//
//接下来你需要进行恰好n-1次删边操作，每次操作你需要选一条未被删去的边，此时这条边所连接的两个结点上的数字将会交换，然后这条边将被删去。
//
//n-1次操作过后，所有的边都将被删去。
//此时，按数字从小到大的顺序，将数字1~n所在的结点编号依次排列，就得到一个结点编号的排列Pi。
//现在请你求出，在最优操作方案下能得到的字典序最小的Pi。
//
//
//如上图，蓝圈中的数字1~5一开始分别在结点②、①、③、⑤、④。
//按照（1)(4)(3)(2）的顺序删去所有边，树变为下图。
//按数字顺序得到的结点编号排列为①③④②⑤，该排列是所有可能的结果中字典序最小的。
//
//
//输入格式
//
//本题输入包含多组测试数据。
//第一行一个正整数T，表示数据组数。
//对于每组测试数据：
//第一行一个整数n，表示树的大小。
//第二行n个整数，第i(1≤i≤n）个整数表示数字i初始时所在的结点编号。
//接下来n-1行每行两个整数x,y，表示一条连接x号结点与y号结点的边。
//
//输出格式
//
//对于每组测试数据，输出一行共 n 个用空格隔开的整数，表示最优操作方案下所能得到的字典序最小的 P
//
//输入样例:
//4
//5
//2 1 3 5 4
//1 3
//1 4
//2 4
//4 5
//5
//3 4 2 1 5
//1 2
//2 3
//3 4
//4 5
//5
//1 2 5 3 4
//1 2
//1 3
//1 4
//1 5
//10
//1 2 3 4 5 7 8 9 10 6
//1 2
//1 3
//1 4
//1 5
//5 6
//6 7
//7 8
//8 9
//9 10
//输出样例:
//1 3 4 2 5
//1 3 5 2 4
//2 3 1 4 5
//2 3 4 5 6 1 7 8 9 10
//
//说明／提示
//【数据范围】
//
//测试点编号   n≤       特殊性质
//1~2          10        无
//3~4          160       树的形态是一条链
//5~7          2000      同上
//8~9          160       存在度数为n-1的结点
//10~12        2000      同上
//13~16        160       无
//17~20        2000      无
//
//对于所有测试点：1≤T≤10，保证给出的是一个树。

