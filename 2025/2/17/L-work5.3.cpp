/*(11)数字变换

//给定一个包含 5 个数字（0~9）的字符串，例如 02943 ，请将 12345 变换到它。
//你可以采取 3 种操作进行变换
//
//1.交换相邻的两个数字。
//
//2.将一个数字加 1 。如果加 1 后大于 9 ，则变为 0 。
//
//3.将一个数字加倍。如果加倍后大于 9 ,则将其变为加倍后的结果除以 10 的余数。
//
//最多只能用第 2 种操作 2 次，第 3 种操作 2 次 求最少经过多少次操作可以完成变换。
//
//输入格式:
//有最多 100000 组数据，每组数据就是包含 5（可能不是5位） 个数字的字符串。
//
//输出格式:
//对每组数据，输出将 12345 变换到给定字符串所需要的最少操作步数。如果无法变换成功，输出 -1。
//
//输入样例:
//12435
//99999
//12374
//输出样例:
//1
//-1
//3


*/

//三逆序组
//
//一个序列中，两个元素 ai 和 aj 逆序，是指它们满足 i<j 且 ai>aj ，这两个元素被称为一个逆序对。
//在 101《数据结构》教材第10章中介绍了利用归并排序求逆序对数量的算法（代码10-14）。
//本题的要求更具挑战一些，要求三逆序组的数量。
//
//所谓三逆序组，即三个元素满足 i<j<k，且 ai>aj>ak 。
//例如在序列 { 5, 1, 4, 3, 2 } 中，共有 4 个三逆序组，分别为（5, 4, 3）、（5, 4, 2）、（5, 3, 2）和（4, 3, 2）。
//为简化问题，我们假设序列 a 是从 1 到 n 的一个排列。
//
//输入格式：
//输入首先在一行中给出一个区间 [3,10^5] 中的正整数 n；
//随后一行给出从 1 到 n 的一个排列。数字间以 1 个空格分隔。
//
//输出格式：
//在一行中输出给定排列中三逆序组的数量。
//
//输入样例：
//22
//1 2 3 4 5 16 6 7 8 9 10 19 11 12 14 15 17 18 21 22 20 13
//输出样例：
//8

#include<iostream>
#include <cstdio>
#include<vector>
using namespace std;
int main()
{
    std::ios::sync_with_stdio(false);
    int n, num = 0;
    cin >> n;
    vector<int>a(n);
    for (int i = 0; i < n; i++)
        cin >> a[i];
    for (int i = 0; i < n; i++)
        for (int j = i + 1; j < n; j++)
            if (a[i] > a[j])
                for (int k = j + 1; k < n; k++)
                    if (a[j] > a[k])
                        num++;
    cout << num << endl;

    return 0;
}
