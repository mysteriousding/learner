/*
翻硬币

题目描述
小明正在玩一个"翻硬币"的游戏。

桌上放着排成一排的若干硬币。
我们用 * 表示正面，用 o 表示反面（是小写字母，不是零）。

比如，可能情形是：**oo***oooo;

如果同时翻转左边的两个硬币，则变为：oooo***oooo。

现在小明的问题是：
如果已知了初始状态和要达到的目标状态，每次只能同时翻转相邻的两个硬币,那么对特定的局面，最少要翻动多少次呢？

我们约定：把翻动相邻的两个硬币叫做一步操作。

输入描述
两行等长的字符串，分别表示初始状态和要达到的目标状态。

每行的长度<1000。

输出描述
一个整数，表示最小操作步数。

输入输出样例
示例

输入
**********
o****o****

输出
5
*/
#include <iostream>
#include<string>
using namespace std;
int main()
{
    string n, m;
    int num = 0;
    cin >> n >> m;
    for (int i = 0; i < m.size() - 1; i++)
        if (n[i] != m[i])
        {
            n[i] = (n[i] == 'o') ? '*' : 'o';
            n[i + 1] = (n[i + 1] == 'o') ? '*' : 'o';
            num++;
        }
    cout << num << endl;

    return 0;
}
