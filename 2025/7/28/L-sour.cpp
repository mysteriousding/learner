/*小骑士过酸水

问题描述
小骑士追着大黄蜂来到一处酸水池前，池子宽度为 n，小骑士一碰到酸水就会挂彩。

现在池面上有几处尖刺露出，接受过魔鬼训练的小骑士可以在尖刺上面短暂的踩一下，来继续向前移动至多 d 距离（n 和 d 均为正整数，且 d≤n）。
换言之，小骑士可以重复执行以下步骤：向前冲刺 a 的距离，然后在尖刺上方短暂停顿，接着继续向前冲刺 b 的距离，再在下一个尖刺上方再短暂停顿，直至成功到达酸水池对岸（其中 a 和 b 均 ≤d）。

问小骑士最少冲刺几次才能到达对岸，如果无法到达则输出 −1 。

输入格式
输入两行。

第一行为一个正整数 d(1≤d≤n−1)。

第二行是一个长度为 n 的无空格字符串，由 + 和 − 组成，+ 表示该点有尖刺，− 代表是酸水。

输出格式
输出一行，为一个整数，即为答案。

样例输入
5
+--++--++++

样例输出
3


说明
在样例中，次数最少的跳法为从位置 1 开始，第一次跳 4 个单位到位置 5，第二次跳 5 个单位到位置 10，第三次跳 1 个单位到终点，总共跳 3 次。

评测数据规模
对于 100%的评测数据，1≤n≤1000，1≤d≤n−1。
*/
#include <iostream>
#include <string>
#include <set>
using namespace std;
set<int>s;
int main()
{
    int d, n, k = 0, ind = 1;
    bool u = 1;
    string m;
    cin >> d >> m;
    n = m.size();
    for (int i = 1; i < n; i++)
        if (m[i] == '+')
            s.insert(i + 1);
    while (ind < n)
    {
        u = 1;
        for (int j = d; j > 0; j--)
            if (s.count(ind + j))
            {
                ind += j;
                k++;
                u = 0;
                break;
            }
        if (u)
        {
            k = -1;
            break;
        }
    }
    cout << k << endl;

    return 0;
}
