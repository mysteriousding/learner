/*
//1. 不油腻的星座【算法赛】
//
//问题描述
//"我们只欢迎不油腻的星座！"
//
//在「非哺乳动物星座联盟」的派对上，主持人突然宣布："请在场的 12 星座中，名字里包含哺乳动物的立刻离场"，结果白羊、金牛、狮子、摩羯 4 个星座红着脸拖着行李箱走了。
//
//现在，请问还有多少星座留在现场？
//
//输入格式
//无。
//
//输出格式
//输出一个整数，表示答案。

#include <iostream>
using namespace std;
int main()
{
  cout<<8<<endl;

  return 0;
}
*/

/*
//2. 守护神开会【算法赛】
//
//问题描述
//白羊座、金牛座和双子座的守护神正在一条直线上开会。起初，他们分别位于坐标 A、B 和 C 三个不同的位置上。
//由于他们说话声音都很小，为了能彼此听得更清楚，每次，最外侧（位置坐标最大或最小）的一位守护神要移动到另外两位守护神之间的空隙处，以便他们三靠得更近。
//
//对此，请你算算，他们最多可以进行多少次这样的移动？注意，他们的位置需始终保持不同。
//
//样例输入
//第一行包含一个整数 T（ 1≤T≤10^5 ），表示测试用例的个数。
//
//接下来 T 行，每行包含三个整数 A、B 和 C（ 1≤A<B<C≤10^9 ），表示三位守护神初始的位置坐标。
//
//样例输出
//输出 T 行，每行一个整数，表示他们最多可以进行多少次移动。
//
//样例输入
//3
//1 2 3
//1 3 5
//1 4 6
//
//样例输出
//0
//1
//2

//#include <iostream>
//using namespace std;
//int main()
//{
//  int t,a,b,c,k,h;
//  bool u;
//  cin>>t;
//  while(t--)
//  {
//    cin>>a>>b>>c;
//    k=0;
//    while(b-a>1||c-b>1)
//    {
//      u=(c-b<b-a)&&b-a>1;
//      h=b;
//      b=(b+(u?a:c))/2;
//      (u?c:a)=h;
//      k++;
//    }
//    cout<<k<<endl;
//  }
//
//  return 0;
//}

#include <iostream>
using namespace std;
int main()
{
  int t,a,b,c;
  cin>>t;
  while(t--)
  {
    cin>>a>>b>>c;
    cout<<max(b-a,c-b)-1<<endl;
  }

  return 0;
}
*/

/*
//3. 守护射手座【算法赛】
//
//问题描述
//射手星座正遭受来自外星系的攻击！星座中有 N 户居民排成一条直线，第 i 户居民有 Ai 人。
//只有当某户居民人数不少于 M 时，该户才能形成防护罩抵御攻击。
//
//国王可以进行迁移操作：每次选择某一户的所有居民，将他们整体迁移到相邻的左边或右边住户。
//由于每次迁移都会消耗大量资源，请计算最少需要多少次迁移，才能使所有住户都形成防御罩低于攻击。
//
//如果无论如何都无法实现，输出 −1。
//
//注意：两户居民合并后为一户，不会存在一个空的户。
//
//输入格式
//第一行两个整数 N,M(1≤N≤10^5 ,1≤M≤10^9 ) 表示射手星座居民数量以及开始防御罩的需要人数。
//
//第二行 N 个整数 A1,A2,⋯,AN (1≤Ai​ ≤10^4 ) 表示每户居民的数量。
//
//输出格式
//输出一个整数表示答案。
//
//样例输入
//6 3
//1 1 2 3 2 1
//
//样例输出
//3
//
//说明
//将 1,2,3 户居民合并为 1 户，需要迁移 2 次。
//
//将 5,6 户居民合并为 1 户，需要迁移 1 次。
//
//最终居民分布为 [4,3,3]，可以抵御住攻击，总共需要迁移 3 次。

#include <iostream>
using namespace std;
int main()
{
  int a[100005],n,m,k=0;
  cin>>n>>m;
  for(int i=0;i<n;i++)
    cin>>a[i];
  for(int i=0;i<n-1;i++)
    if(a[i]<m)
      a[i+1]+=a[i],k++;
  if(a[n-1]<m)k++;
  cout<<(k==n?-1:k)<<endl;

  return 0;
}
*/

/*
//4. 星座骑士【算法赛】
//
//问题描述
//在一次盛大的十二星座大会上，各星座代表齐聚一堂，共同商议组建一支星座守护军队，以应对可能出现的突发情况。这支军队不仅需要强大的战斗力，还需要有卓越的领导才能。
//经过严格的选拔，最终从十二星座中挑选出了 N 位星座骑士，他们各自展现出独特的能力值，记为 Ai 。
//
//为了确保军队的高效运作，会议决定选出两位星座骑士作为左右统帅。
//然而，统帅的选择并非随意，而是有着特殊的要求：
//这两位统帅的能力值之和必须与剩余骑士的能力值之和保持相同的奇偶性。
//这一规定旨在确保军队在战斗时的稳定性，避免潜在的混乱和冲突。
//
//请你帮忙计算一下最终能选出多少种符合条件的统帅组合。
//
//输入格式
//第一行输入一个整数 N（ 2≤N≤10^5 ），表示星座骑士的数量。
//
//第二行输入 N 个整数 A1,A2,…,AN（ 1≤Ai​≤10^9 ），表示每位星座骑士的能力值。
//
//输出格式
//输出一个整数，表示符合条件的统帅组合的数量。
//
//样例输入
//5
//3 4 4 6 7
//
//样例输出
//10

#include <iostream>
using namespace std;
int main()
{
  int m,k;
  long n;
  cin>>n;
  for(int i=0;i<n;i++)
  {
    cin>>k;
    m+=k%2;
  }
  cout<<(m%2?0:n*(n-1)/2)<<endl;

  return 0;
}
*/

/*



*/
