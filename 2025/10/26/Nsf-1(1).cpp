/*
链接：https://ac.nowcoder.com/acm/contest/20960/1001

本题转译自 [NOIP2007] 字符串的展开 。

对于给定由减号 "-" 、小写字母和数字组成的字符串 s ，我们认为减号是一种简写，在完整的输出时，需要用连续递增的字母或数字串替代其中的减号。
例如，将 "d-h" 和 "4-8" 分别输出为 "defgh" 和 "456788"。
具体地，我们这样定义展开规则：
当出现一个减号时，若它不位于字符串的开头或结尾、且其两侧为同类型的字符（都是小写字母或都是数字）、且右侧字符的 ASCII 码大于左侧字符时，则需要展开该片段。

特别的，在本题中，展开规则还由一个三元组 (p1 ,p2 ,p3​ ) 额外控制：
p1 控制展开方式：
∙当 p1=1 时：若减号两侧为字母，则用小写字母填充；若为数字，则用数字填充。
∙当 𝑝1=2 时：若减号两侧为字母，则用大写字母填充；若为数字，则用数字填充。
∙当 p1=3 时，无论减号两侧为何种字符，都用星号 "*" 填充；
p2 控制每个填充字符重复的次数：即无论字符类型如何，每个待填充字符都要连续输出 p2 次。
例如，当 p2=3 时，子串 "d-h" 应扩展为 "deeefffgggh"。
p3 控制是否逆序输出填充部分：
∙当 p3=1 时，表示维持原有顺序；
∙当 p3=2 时，表示采用逆序输出。
例如当 p1=1; p2=2; p3=2 时，子串 "d-h" 应扩展为 "dggffeeh"。

还需要注意以下特殊情况：
∙如果右侧字符是左侧字符的直接后继（如 "d-e" 或 "3-4" ），则只需删除减号；
∙如果右侧字符的 ASCII 码小于等于左侧字符，则保持原样输出（包含减号）。


输入描述:
第一行输入三个整数 p1 p2 p3(1≤p1≤3; 1≤p2≤8; 1≤p3≤2) 代表展开规则中的 p1 p2 p3 。
第二行输入一个长度不超过 100 ，由减号 "-" 、小写字母和数字组成的字符串 s ，代表需要展开的字符串。


输出描述:
在一行上输出一个字符串，代表展开后的答案。
示例1
输入
1 2 1
abcs-w1234-9s-4zz
输出
abcsttuuvvw1234556677889s-4zz
说明
在这一组测试数据中，答案为 "abcsttuuvvw1234556677889s-4zz" 。

示例2
输入
2 3 2
a-d-d
输出
aCCCBBBd-d

示例3
输入
3 4 2
di-jkstra2-6
输出
dijkstra2************6

备注:
如果你需要 Ascii 码相关的帮助，请参阅下表。
https://uploadfiles.nowcoder.com/images/20241209/0_1733684064187/B4D4270A317A83791696FEAA6578C14F
*/
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int a, b, c, d;
    string n, m = "", h = "0aA";
    cin >> a >> b >> c;
    cin.ignore();
    getline(cin, n, '\n');
    m += n[0];
    for (int i = 1; i < n.size() - 1; i++)
        if (n[i] == '-' && n[i + 1] > n[i - 1] && n[i + 1] - n[i - 1] < 26 && n[i - 1] != '-')
        {
            if (a == 3)
                for (int j = n[i - 1] + 1; j < n[i + 1]; j++)
                    for (int l = 0; l < b; l++)
                        m += '*';
            else
            {
                d = n[i + 1] <= '9' ? h[a] : n[i + 1] < 'a' ? 'A' : 'a';

                if (c == 1)
                    for (int j = n[i - 1] + 1; j < n[i + 1]; j++)
                        for (int l = 0; l < b; l++)
                            m += char(j - d + h[a]);
                else
                    for (int j = n[i + 1] - 1; j > n[i - 1]; j--)
                        for (int l = 0; l < b; l++)
                            m += char(j - d + h[a]);
            }
        }
        else m += n[i];
    m += n[n.size() - 1];
    cout << m << endl;

    return 0;
}
