/*
例8-校门外的树：easy

题目描述
本题转译自 [NOIP2005 普及组] 校门外的树。
本题为简单版本，与困难版本的区别仅在数据的范围上。
某校大门外长度为 l 的马路上有一排树，每两棵相邻的树之间的间隔都是 1 米。
我们可以把马路看成一个数轴，马路的一端在数轴 0 的位置，另一端在 l 的位置；
数轴上的每个整数点，即 0,1,2,…,l 都种有一棵树。
由于马路上有一些区域要用来建地铁，现在要把这些区域中的树（包括区域端点处的两棵树）移走。
这些区域用它们在数轴上的起始点和终止点表示。
已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。
你的任务是计算将这些树都移走后，马路上还有多少棵树。


输入描述:
第一行输入两个整数 l,n(1≦l≦10^4 ; 1≦n≦100) 代表马路长度、移植的区域数目。
此后 n 行，第 i 行输入两个整数 li ,ri (1≦li ≦ri ≦l) 代表第 i 个移植区域的起始、中止坐标。


输出描述:
在一行上输出一个整数，代表马路上剩余的树的数目。
示例1
输入 
500 3
150 300
100 200
470 471
输出
298
说明
在这个样例中，留下 1∼99 、301∼469 和 472∼500 的树，共 100+169+29=298 棵。
*/
#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;
struct d
{
    int a, b;
};
bool pd(d& x, d& y)
{
    return x.a < y.a;
}
int main()
{
    int n, m, u, v, num;
    cin >> n >> m;
    vector<d>r(m);
    for (int i = 0; i < m; i++)
        cin >> r[i].a >> r[i].b;
    sort(r.begin(), r.end(), pd);
    u = 0, v = 1, num = n + 1;
    while (u < v)
        if (r[u].b > r[v].a)
        {
            r[u].b = r[u].b > r[v].b ? r[u].b : r[v].b;
            r[v].b = r[v].a - 1;
            v++;
        }
        else u++;
    for (int i = 0; i < m; i++)
        num -= r[i].b - r[i].a + 1;
    cout << num << endl;

    return 0;

}




