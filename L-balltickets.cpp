/*
赢球票

题目描述
某机构举办球票大奖赛。获奖选手有机会赢得若干张球票。

主持人拿出 N 张卡片（上面写着 1⋯N 的数字），打乱顺序，排成一个圆圈。

你可以从任意一张卡片开始顺时针数数: 1,2,3 ⋯⋯

如果数到的数字刚好和卡片上的数字相同，则把该卡片收入囊中，从下一个卡片重新数数。

直到再无法收获任何卡片，游戏结束。囊中卡片数字的和就是赢得球票的张数。

比如：

卡片排列是：1 2 3

我们从 1 号卡开始数，就把 1 号卡拿走。再从 2 号卡开始，但数的数字无法与卡片对上，很快数字越来越大，不可能再拿走卡片了。
因此这次我们只赢得了 1 张球票。

还不算太坏！如果我们开始就傻傻地从 2 或 3 号卡片数起，那就一张卡片都拿不到了。

如果运气好，卡片排列是 2 1 3，那我们可以顺利拿到所有的卡片！

本题的目标：已知顺时针卡片序列，随便你从哪里开始数，求最多能赢多少张球票（就是收入囊中的卡片数字之和）

输入描述
第一行一个整数 N ( N≤100)，表示卡片数目。

第二行 N 个整数，表示顺时针排列的卡片。

输出描述
输出一行，一个整数，表示最好情况下能赢得多少张球票。

输入输出样例
示例
输入

3
1 2 3

输出

1
*/
#include <iostream>
#include<cstring>
using namespace std;
int m[105], mem[105];
int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
        cin >> m[i];
    memcpy(mem, m, sizeof(mem));
    bool u = 1;
    int k, l, sum, j, max = 0;
    for (int i = 0; i < n; i++)
    {
        l = 0, j = i, k = 1, sum = 0;
        memcpy(m, mem, sizeof(m));
        while (1)
        {
            if (m[j] == -1);
            else if (m[j] != k)k++;
            else if (m[j] == k)m[j] = -1, sum += k, k = 1, l++;
            j++;
            if (j == n)j = 0;
            if (k > n || l == n)break;
        }
        if (max < sum)max = sum;
    }
    cout << max << endl;

    return 0;
}