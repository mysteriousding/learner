//链接：https://ac.nowcoder.com/acm/contest/120563
//来源：牛客网
/* A √
宙天

题目描述
小红正在探索宇宙的奥秘，她认为某些数字承载着特殊的意义。
小红定义一个正整数
𝑥
x 为「终极答案」，当且仅当它能表示为两个连续自然数的乘积。
形式化的，若存在自然数
𝑘
k，满足
𝑥
=
𝑘
×
(
𝑘
+
1
)
x=k×(k+1)，则称
𝑥
x 为「终极答案」。
给定一个正整数
𝑥
x，请你帮小红判断它是否是一个「终极答案」。
输入描述:
在一行上输入一个整数
𝑥
(
1
≦
𝑥
≦
100
)
x(1≦x≦100)。
输出描述:
如果
𝑥
x 是一个「终极答案」，输出
YES
YES；否则输出
NO
NO。
示例1
输入
复制
42
输出
复制
YES
说明
在这个样例中，
𝑥
=
42
=
6
×
7
x=42=6×7。由于
6
6 和
7
7 是两个连续的自然数，因此
42
42 是一个「终极答案」。
示例2
输入
复制
5
输出
复制
NO
*
#include<iostream>
#include<cmath>
using namespace std;
int main()
{
    int n, k;
    cin >> n;
    k = pow(n, 0.5);
    cout << (n == k * ++k ? "YES" : "NO") << endl;

    return 0;
}
*/

/* B √
Random

题目描述
小红拿到了一个长为
𝑛
n 的数组
𝑎
1
,
𝑎
2
,
…
,
𝑎
𝑛
a
1
​
 ,a
2
​
 ,…,a
n
​
 。她想要选择其中两个不同位置的元素，要求这两个元素的最大公约数大于
1
1，请你帮帮她。
特殊的，保证数组元素在
[
1
,
1
0
9
]
[1,10
9
 ] 范围内独立均匀随机生成。

【名词解释】
最大公约数（gcd）：指两个或多个整数共有约数中最大的一个。例如，
12
12 和
30
30 的公约数有
1
,
2
,
3
,
6
1,2,3,6，其中最大的约数是
6
6，因此记作
gcd
⁡
(
12
,
30
)
=
6
gcd(12,30)=6。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
𝑇
(
1
≦
𝑇
≦
1
0
4
)
T(1≦T≦10
4
 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数
𝑛
(
1
≦
𝑛
≦
2
×
1
0
5
)
n(1≦n≦2×10
5
 )，代表数组长度。
第二行输入
𝑛
n 个整数
𝑎
1
,
𝑎
2
,
…
,
𝑎
𝑛
(
1
≦
𝑎
𝑖
≦
1
0
9
)
a
1
​
 ,a
2
​
 ,…,a
n
​
 (1≦a
i
​
 ≦10
9
 )，代表数组元素。

除此之外，保证单个测试文件的
𝑛
n 之和不超过
2
×
1
0
5
2×10
5
 。
输出描述:
对于每组测试数据，如果不存在符合要求的两个元素，直接输出
−
1
−1；否则，在一行上输出两个整数，代表选中的两个元素的值。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2
5
101770993 7791101 39239295 480041099 460611962
5
981262894 280102212 13579679 112334424 10169419
输出
复制
-1
981262894 280102212
备注:
在几乎全部的情况下，PyPy 的运行速度优于 Python，我们建议您选择对应版本的 PyPy 进行提交、而不是 Python。
*
#include<iostream>
#include<vector>
using namespace std;
bool gcd(int x, int y)
{
    int z = 1;
    while (z)
    {
        z = x % y;
        x = y;
        y = z;
    }
    return x != 1;
}
int main()
{
    int t, n;
    bool v;
    vector<int>a;
    cin >> t;
    while (t--)
    {
        v = 1;
        cin >> n;
        a.resize(n);
        for (int i = 0; i < n; i++)
            cin >> a[i];
        for (int i = 0; v && i < n - 1; i++)
            for (int j = i + 1; v && j < n; j++)
                if (gcd(a[i], a[j]))
                {
                    v = 0;
                    cout << a[i] << " " << a[j] << endl;
                }
        if (v)cout << -1 << endl;
    }

    return 0;
}
*/

/* C
Inverted World

题目描述
小芳拿到了一个仅由字符
0
0 和
1
1 组成的长为
n
n 的字符串
s
s，他可以进行任意次如下操作：
∙
 
∙选择
s
s 的一个非空子序列
[1]
[1]
 ，该子序列任意两个相邻元素都不相同，将该子序列进行 01 反置
[2]
[2]
 。
小芳想知道，最少需要多少次操作才能使得
s
s 中任意两个相邻元素都不相同？

【名词解释】
子序列
[1]
[1]
 ：从原序列中删除任意个（可以为零，也可以为全部）元素，且保持剩余元素相对顺序不变得到的新序列。
01 反置
[2]
[2]
 ：同时将字符串中的
0
0 变成
1
1，
1
1 变成
0
0。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≦
T
≦
1
0
4
)
T(1≦T≦10
4
 ) 代表数据组数，每组测试数据描述如下：

第一行输入一个整数
n
(
1
≦
n
≦
2
×
1
0
5
)
n(1≦n≦2×10
5
 )，代表字符串长度。
第二行输入一个长为
n
n，仅由字符
0
0 和
1
1 构成的字符串
s
s。

除此之外，保证单个测试文件的
n
n 之和不超过
2
×
1
0
5
2×10
5
 。
输出描述:
对于每组测试数据，新起一行输出一个整数，代表所需要的最少操作次数。
示例1
输入
复制
2
5
11101
5
11100
输出
复制
1
1
说明
对于第一组测试数据，一种可行的操作方法为
1
1
‾
101
→
1
0
‾
101
1
1
​
 101→1
0
​
 101。

对于第二组测试数据，一种可行的操作方法为
1
1
‾
10
0
‾
→
1
0
‾
10
1
‾
1
1
​
 10
0
​
 →1
0
​
 10
1
​
 。


*
#include<iostream>
#include<string>
using namespace std;
int main()
{
    int t, n;
    string s;
    char f;
    bool v;
    cin >> t;
    while (t--)
    {
        v = 1;
        cin >> n;
        cin.ignore();
        getline(cin, s);
        for (int i = 1; i < n; i++)
            if (s[i] != s[i - 1])
            {
                v = 0;
                break;
            }
        if (v)
        {
            cout << 0 << endl;
            continue;
        }
        v = 1;
        f = s[0];
        for (char c : s)
            if (c != f)
            {
                v = 0;
                break;
            }
        cout << 1 + v << endl;
    }

    return 0;
}
*/

/* D
系ぎて

题目描述
小红正在一块
n
n 行
m
m 列的电路板上修复信号。电路板的每个格点上可能标记着数字
0
0、
1
1 或
2
2。其中，标记为
1
1 的格点恰好有两个，标记为
2
2 的格点也恰好有两个，其余格点均为
0
0。

小红需要规划两条路径，分别连接两个
1
1 信号点和两个
2
2 信号点。
一条合法的路径定义为：
∙
∙ 路径由一系列相邻的格子组成（上、下、左、右）。
∙
∙ 两条路径不能经过同一个格子。
∙
∙ 每条路径不能经过不属于该路径的信号点（例如，连接
1
1 的路径不能经过任何标记为
2
2 的格点）。
∙
∙ 路径可以经过标记为
0
0 的格点，每个
0
0 格点最多只能被一条路径使用一次。

请你帮小红判断是否存在这样的两条路径。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≦
T
≦
1
0
4
)
T(1≦T≦10
4
 ) 代表数据组数，每组测试数据描述如下：

第一行输入两个整数
n
,
m
(
2
≦
n
,
m
≦
1
0
5
)
n,m(2≦n,m≦10
5
 )，表示网格的行数和列数。
接下来
n
n 行，每行输入一个长度为
m
m 的字符串，由字符
0
0、
1
1、
2
2 组成，表示电路板的每个格点上的标记。保证
1
1 和
2
2 的数量恰好为
2
2。

除此之外，保证单个测试文件的
n
×
m
n×m 之和不超过
1
0
5
10
5
 。
输出描述:
对于每组测试数据，新起一行输出
YES
YES 或
NO
NO，表示是否存在满足要求的两条路径。
示例1
输入
复制
3
2 2
12
21
2 2
11
22
3 3
010
212
000
输出
复制
NO
YES
YES
说明
对于第一组测试数据，两个
1
1 和两个
2
2 呈对角分布，连接其中一对必会阻断另一对，无法构造不相交路径。

对于第二组测试数据，两个
1
1 都在第一行，两个
2
2 都在第二行，可以分别在各自行内水平连接。

对于第三组测试数据，连接了两个
1
1 后，两个
2
2 可以从下方绕成一个连通的路径。
*/

/* E
躯树の墓守

题目描述
小芳最近学会了最小生成树，现在她想要用几道题来检验自己。
请你生成一个包含
n
n 个点，
m
m 条边，对于每条边的边权
w
i
w
i
​
  都有
w
i
∈
[
1
,
m
]
w
i
​
 ∈[1,m] 且边权互不相同的无向简单连通图
[1]
[1]
 ，它的最小生成树
[2]
[2]
 的边权之和恰好为
k
k。点的编号为
1
1 到
n
n。

【名词解释】
简单连通图
[1]
[1]
 ：指不包含自环（连接节点自身的边）和重边（两个节点之间存在多条边）、且任意两个顶点之间都存在路径相连的图。
最小生成树
[2]
[2]
 ：对于一张由
n
n 个节点构成的连通图，选出
n
−
1
n−1 条边将所有节点连通，且使得这
n
−
1
n−1 条边的权重之和最小，这样的结构称为最小生成树。
输入描述:
每个测试文件均包含多组测试数据。第一行输入一个整数
T
(
1
≦
T
≦
1
0
4
)
T(1≦T≦10
4
 ) 代表数据组数，每组测试数据描述如下：

第一行输入三个整数
n
,
m
,
k
(
1
≦
n
≦
2
×
1
0
5
;
 
n
−
1
≦
m
≦
min
⁡
(
2
×
1
0
5
,
n
(
n
−
1
)
2
)
;
 
1
≦
k
≦
1
0
9
)
n,m,k(1≦n≦2×10
5
 ;n−1≦m≦min(2×10
5
 ,
2
n(n−1)
​
 );1≦k≦10
9
 )。

除此之外，保证单个测试文件的
n
n 之和、
m
m 之和均不超过
2
×
1
0
5
2×10
5
 。
输出描述:
对于每组测试数据，如果不存在符合要求的图，直接输出
NO
NO；否则：
∙
 
∙第一行输出
YES
YES；
∙
 
∙此后
m
m 行，第
i
i 行输出三个整数
u
i
,
v
i
,
w
i
u
i
​
 ,v
i
​
 ,w
i
​
 ，表示第
i
i 条边连接点
u
i
,
v
i
u
i
​
 ,v
i
​
 ，边权为
w
i
w
i
​
 。

如果存在多个解决方案，您可以输出任意一个，系统会自动判定是否正确。注意，自测运行功能可能因此返回错误结果，请自行检查答案正确性。
示例1
输入
复制
2
4 5 6
3 2 4
输出
复制
YES
1 2 1
2 3 2
3 4 3
3 1 4
4 2 5
NO
*/
