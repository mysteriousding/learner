/*
寻找岛屿的周长

题目描述
实现一个算法找到岛屿的周长。
介绍如下：

给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地， 0 表示水域。

网格单元在水平和垂直方向上连接。
网格完全被水包围，并且网格上只有一个岛，岛上没有湖泊。

网格中一个单元是一个边长为 1 的正方形。
网格是矩形，宽度和高度不超过 100。

需要实现一个算法确定岛的周长。
岛的周长指的是 1 与 0 相邻的边的个数乘以边长。

例如对于如下网格单元构成的岛屿，周长为 16。

    [[0,1,0,0],
     [1,1,1,0],
     [0,1,0,0],
     [1,1,0,0]]

输入描述
第一行输入两个数字 N，M（1<N,M<1000），表示网格地图的高和宽。

接下来 N 行，每行 M 个元素，为网格地图。

输出描述
输出一个数字，为岛屿的周长。

输入输出样例
示例

输入
4 4
0 1 0 0
1 1 1 0
0 1 0 0
1 1 0 0

输出
16
*/
#include <iostream>
using namespace std;
int main()
{
    int n, m, h = 0;
    bool a[102][102] = { 0 };
    cin >> n >> m;
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            cin >> a[i][j];
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= m; j++)
            if (a[i][j])
            {
                if (!a[i - 1][j])h++;
                if (!a[i + 1][j])h++;
                if (!a[i][j - 1])h++;
                if (!a[i][j + 1])h++;
            }
    cout << h << endl;

    return 0;
}